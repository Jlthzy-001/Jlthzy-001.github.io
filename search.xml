<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python threading模块thread类</title>
      <link href="/2022/07/26/Python%20threading%E6%A8%A1%E5%9D%97thread%E7%B1%BB/"/>
      <url>/2022/07/26/Python%20threading%E6%A8%A1%E5%9D%97thread%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程优势">多线程优势</h2><p>1.线程比进程更轻量化，系统开销一般也更低</p><h2 id="创建thread对象的两种方法">创建thread对象的两种方法</h2><p>1.直接创建 Thread ，将一个 callable 对象从类的构造器传递进去，这个 callable 就是回调函数，用来处理任务。</p><p>2.编写一个自定义类继承 Thread，然后复写 run() 方法，在 run() 方法中编写任务处理代码，然后创建这个 Thread 的子类。</p><h3 id="1-直接创建Thread-对象">1.直接创建Thread 对象</h3><p>标准范式，将一个 callable 对象赋值给target，线程即可正常运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threading</span>.<span class="title">Thread</span>(<span class="params">group=<span class="literal">None</span>, target=<span class="literal">None</span>, name=<span class="literal">None</span>, args=(<span class="params"></span>), kwargs=&#123;&#125;, *, daemon=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure><h4 id="实验1-初识线程">实验1 初识线程</h4><p>实验代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func1&#x27;</span>, i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">demo_thread = threading.Thread(target=func1)</span><br><span class="line">demo_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;***&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>程序运行时，默认是在主线程上的，子线程demo_thread先于主线程开始，但是由于sleep的缘故，实际上子线程是晚于主线程结束运行的</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220725233916.png" alt=""></p><h4 id="实验2-线程名称打印">实验2 线程名称打印</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name,<span class="string">&quot;of func1: &quot;</span>, i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">demo_thread = threading.Thread(target=func1)</span><br><span class="line">demo_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name, <span class="string">&quot;of ***: &quot;</span>, i)</span><br></pre></td></tr></table></figure><p>在主线程打印<code>current_thread().name</code>会直接显示<code>Mainthread</code></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220725234541.png" alt=""></p><p>当然也可以在<code>demo_thread</code>中可以自定义<code>name</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo_thread = threading.Thread(target=func1,name=<span class="string">&#x27;TestThread&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="实验3-线程生命周期">实验3 线程生命周期</h4><p>线程也是有生命周期的</p><ol><li>创建对象时，代表 Thread 内部被初始化。</li><li>调用 start() 方法后，thread 会开始运行。</li><li>thread 代码正常运行结束或者是遇到异常，线程会终止</li></ol><p>可以用过<code> is_alive()</code>方法，查询线程是否还在运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func1: &quot;</span>, i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">demo_thread = threading.Thread(target=func1)</span><br><span class="line">demo_thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(demo_thread.name,<span class="string">&quot;is alive &quot;</span>, demo_thread.isAlive())</span><br></pre></td></tr></table></figure><p>实验结果</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220725235707.png" alt=""></p><h4 id="实验4-join阻塞主线程">实验4 join阻塞主线程</h4><p>直到子线程<code>demo_thread</code>结束后，主线程才继续进行下去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func1: &quot;</span>, i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">demo_thread = threading.Thread(target=func1)</span><br><span class="line">demo_thread.start()</span><br><span class="line">demo_thread.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(demo_thread.name,<span class="string">&quot;is alive &quot;</span>, demo_thread.isAlive())</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220726000137.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDB断点调试</title>
      <link href="/2022/07/23/python%20pdb%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2022/07/23/python%20pdb%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="PDB断点调试">PDB断点调试</h2><h3 id="1-两种进入pdb的方法">1.两种进入pdb的方法</h3><p>pdb有2种用法：</p><ul><li><strong>非侵入式方法</strong>（不用额外修改源代码，在命令行下直接运行就能调试）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb filename.py</span><br></pre></td></tr></table></figure><ul><li><strong>侵入式方法</strong>（需要在被调试的代码中添加一行代码然后再正常运行代码）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pdb;pdb.set_trace()</span><br></pre></td></tr></table></figure><p>当你在命令行看到下面这个提示符时，说明已经正确打开了pdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) </span><br></pre></td></tr></table></figure><h3 id="2-pdb常见命令缩写">2.pdb常见命令缩写</h3><p>参考文献：<a href="https://blog.csdn.net/qq_37049781/article/details/84635652">https://blog.csdn.net/qq_37049781/article/details/84635652</a></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220723182428461.png" alt=""></p><h3 id="3-常用指令实验">3.常用指令实验</h3><p>本次实验所使用的python代码，非常简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1 is executing now!&quot;</span>)</span><br><span class="line">    c = a + b</span><br><span class="line">    d = c * <span class="number">12</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c = &quot;</span>, c, <span class="string">&quot;d = &quot;</span>, d)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1 completed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&quot;please input num1:&quot;</span>)</span><br><span class="line">    b = <span class="built_in">input</span>(<span class="string">&quot;please input num2:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;type a: &quot;</span>, <span class="built_in">type</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;type b: &quot;</span>, <span class="built_in">type</span>(b))</span><br><span class="line">    c = <span class="built_in">int</span>(a) * <span class="built_in">int</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    func1(a, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Over&quot;</span>)</span><br></pre></td></tr></table></figure><p>当在python pdb环境进行测试时，执行pdb不知道的指令，环境会将指令作为语句来执行</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220723185053347.png" alt=""></p><h4 id="3-1-查看源代码">3.1 查看源代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前位置前后11行源代码（多次会翻页）</span></span><br><span class="line"><span class="comment"># 当前位置在代码中会用--&gt;这个符号标出来</span></span><br><span class="line">l</span><br><span class="line"><span class="comment"># 查看当前函数或框架的所有源代码</span></span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h4 id="3-2-添加断点">3.2 添加断点</h4><p>在非侵入式打断点的情况下，可以手动添加断点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b后面得空行</span></span><br><span class="line">b line  <span class="comment"># lineno断点添加到哪一行</span></span><br><span class="line">b func_name  <span class="comment"># 函数名，在该函数执行的第一行设置断点</span></span><br><span class="line">b file_name:line  <span class="comment"># 在filename文件的line行添加断点</span></span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723204002.png" alt=""></p><p>这个时候再执行<code>ll</code>指令可以查看断点标记的位置</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723204138.png" alt=""></p><h4 id="3-3-删除断点">3.3 删除断点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不带参数，可用于清除所有的断点</span></span><br><span class="line">cl</span><br><span class="line"><span class="comment"># 带一个数字参数，表示断点的序号，根据断点加入的顺序，从1开始排序</span></span><br><span class="line">cl <span class="number">1</span>  <span class="comment"># 删除第1个加入的断点</span></span><br><span class="line"><span class="comment"># 删除指定文件某行的断点</span></span><br><span class="line">cl file_name:line</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723210054.png" alt=""></p><h4 id="3-4打印变量值·">3.4打印变量值·</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印变量a的值</span></span><br><span class="line">p var_a</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723210409.png" alt=""></p><h4 id="3-5-逐行调试命令">3.5 逐行调试命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下一行（能够进入函数体）</span></span><br><span class="line">s</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723210648.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下一行（不会进入函数体）</span></span><br><span class="line">n</span><br></pre></td></tr></table></figure><p>在函数func1处打断点，执行n之后，不会进入函数体，待函数执行完毕，自动定位到函数的下一行语句</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723211343.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下一行（在函数中时会直接执行到函数返回处）</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>实验下来<code>r</code>和<code>n</code>很相似，但是<code>r</code>似乎是main函数执行完后再回到函数的下一行语句！</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723211958.png" alt=""></p><h4 id="3-6-非逐行调试命令">3.6 非逐行调试命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 持续执行下去，直到遇到一个断点</span></span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>在第15行的位置打断点</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723212532.png" alt=""></p><p>执行<code>c</code>之后直接执行到了断点处</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723212613.png" alt=""></p><h4 id="3-7-查看函数参数">3.7 查看函数参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在函数中时打印函数的参数和参数的值</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>执行<code>s</code>指令后，进入函数体，再执行<code>a</code>查看输入函数的参数</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723212756.png" alt=""></p><h4 id="3-8-打印变量类型">3.8 打印变量类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印表达式的类型，常用来打印变量值，和print(type)是一个意思</span></span><br><span class="line">whatis</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723212927.png" alt=""></p><h4 id="3-9-打印堆栈信息">3.9 打印堆栈信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印堆栈信息，最新的帧在最底部。箭头表示当前帧</span></span><br><span class="line">w</span><br></pre></td></tr></table></figure><p>在执行函数完成后，输入<code>w</code>指令，查看堆栈</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220723213202.png" alt=""></p><h4 id="3-10-退出pdb调试环境">3.10 退出pdb调试环境</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 退出pdb</span></span><br><span class="line">q</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
            <tag> python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令行</title>
      <link href="/2022/07/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2022/07/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要分为2个部分，一是linux环境下常用的操作指令，二是网络相关的指令，一并整理！</p><blockquote><p>实验环境：腾讯云轻量上海</p><p>持续更新ing~</p></blockquote><h2 id="Linux常用操作命令">Linux常用操作命令</h2><p>善于使用通配符*</p><h3 id="1-rm删除指令">1.rm删除指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除单个文件or目录</span></span><br><span class="line">rm file_name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前目录下所有文件(未隐藏文件)，加-r递归参数可删除目录</span></span><br><span class="line">rm *</span><br><span class="line">rm -r *</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前目录下所有以a开头的文件，并且在每次删除时，提示用户进行确认，加-r递归参数可删除目录</span></span><br><span class="line">rm -i a*</span><br><span class="line">rm -r -i a*</span><br></pre></td></tr></table></figure><h3 id="2-ls查阅指令">2.ls查阅指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给出当前目录下所有文件的一个长列表，包括以句点开头的“隐藏”文件</span></span><br><span class="line">ls -la</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录下以a开头的所有文件</span></span><br><span class="line">ls a*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给出当前目录下以.txt结尾的所有文件，其它目录同理</span></span><br><span class="line">ls -l *.txt</span><br></pre></td></tr></table></figure><h3 id="3-cp复制命令">3.cp复制命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把文件复制为新文件dc.txt，创建一个新的文件，内容和原文件一致</span></span><br><span class="line">cp lc.txt dc.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把文件la.txt从当前目录复制到/home/pkg/目录下</span></span><br><span class="line">cp la.txt /home/pkg/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把当前目录下的所有未隐藏文件复制到/home/pkg/目录下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 善于使用通配符*</span></span><br><span class="line">cp * /home/pkg/</span><br></pre></td></tr></table></figure><h3 id="4-mv移动指令">4.mv移动指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同目录下使用，等于重命名，将dc.txt重命名为ec.txt</span></span><br><span class="line">mv dc.txt ec.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下la.txt 移动到指定目录</span></span><br><span class="line">mv la.txt /home/pkg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下所有文件移动到指定目录</span></span><br><span class="line">mv * /home/pkg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前目录下指定文件移动到指定目录</span></span><br><span class="line">mv *.txt /home/pkg</span><br><span class="line">mv file* /home/pkg</span><br></pre></td></tr></table></figure><h3 id="5-cd进入命令">5.cd进入命令</h3><p>比较简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到主目录</span></span><br><span class="line">cd ~</span><br></pre></td></tr></table></figure><h3 id="6-grep搜索指令">6.grep搜索指令</h3><p>记录下常用的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下查找关键字为xxx的文件</span></span><br><span class="line">ll | grep xxx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件exports中查找包含demo的所有行,直接使用grep查找的是内容</span></span><br><span class="line">grep demo /home/pkg/exports</span><br></pre></td></tr></table></figure><h3 id="7-cat读取指令">7.cat读取指令</h3><p>cat主要用来读取可读文件中的内容，和6中的grep有相通的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接读就OK</span></span><br><span class="line">cat file_name.txt</span><br></pre></td></tr></table></figure><h3 id="x-其它指令">x.其它指令</h3><h4 id="1-vim全选-复制-删除">1.vim全选 复制 删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全选</span></span><br><span class="line">按esc后，然后ggvG或者ggVG</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全部复制</span></span><br><span class="line">按esc后，然后ggyG</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全部删除</span></span><br><span class="line">按esc后，然后dG</span><br></pre></td></tr></table></figure><h2 id="Linux-ip类指令">Linux ip类指令</h2><h3 id="1-命令详解">1.命令详解</h3><p><code>ip</code> 常用命令格式如下：</p><p><code>ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</code></p><p>对象 <code>OBJECT=&#123; link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token &#125;</code></p><p>选项 <code>OPTIONS=&#123; -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] &#123; inet | inet6 | ipx | dnet | link &#125; | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] &#125;</code></p><p>eg:</p><blockquote><p>ip -V address show</p></blockquote><p>常用对象的取值含义如下：</p><ul><li><code>link</code> ：网络设备</li><li><code>address</code> ：设备上的协议（IP 或 IPv6）地址</li><li><code>addrlabel</code> ：协议地址选择的标签配置</li><li><code>route</code> ：路由表条目</li><li><code>rule</code> ：路由策略数据库中的规则</li></ul><p>常用选项的取值含义如下：</p><ul><li><code>-V，-Version</code> ：显示指令版本信息</li><li><code>-s，-stats，statistics</code> ：输出详细信息</li><li><code>-h，-human，-human-readable</code> ：输出人类可读的统计信息和后缀</li><li><code>-o，-oneline</code> ：将每条记录输出到一行，用‘'字符替换换行符</li></ul><h3 id="2-使用实例-检查网卡信息">2.使用实例-检查网卡信息</h3><p>执行命令： <code>ip addr show</code>，显示网卡及配置的地址信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:1e:4f:c8:43:fc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.24/24 brd 192.168.0.255 scope global eth0</span><br><span class="line">    valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这个系统有两个接口：lo 和 eth0，lo 是环回接口，而我们重点关注的则是 eth0 这个普通网络接口；</p><ul><li><code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code> ： <code>BROADCAST</code> 表示该接口支持广播； <code>MULTICAST</code> 表示该接口支持多播； <code>UP</code> 表示该网络接口已启用； <code>LOWER_UP</code> 表示网络电缆已插入，设备已连接至网络</li><li><code>mtu 1500</code> ：最大传输单位（数据包大小）为 1,500 字节</li><li><code>qdisc pfifo_fast</code> ：用于数据包排队</li><li><code>state UP</code> ：网络接口已启用</li><li><code>qlen 1000</code> ：传输队列长度</li><li><code>link/ether 00:1e:4f:c8:43:fc</code> ：接口的 MAC（硬件）地址</li><li><code>brd ff:ff:ff:ff:ff:ff</code> ：广播地址</li><li><code>inet 192.168.0.24/24</code> ：IPv4 地址</li><li><code>brd 192.168.0.255</code> ：广播地址</li><li><code>scope global</code> ：全局有效</li><li><code>dynamic enp0s25</code> ：地址是动态分配的</li><li><code>valid_lft forever</code> ：IPv4 地址的有效使用期限</li><li><code>preferred_lft forever</code> ：IPv4 地址的首选生存期</li><li><code>inet6 fe80::2c8e:1de0:a862:14fd/64</code> ：IPv6 地址</li><li><code>scope link</code> ：仅在此设备上有效</li><li><code>valid_lft forever</code> ：IPv6 地址的有效使用期限</li><li><code>preferred_lft forever</code> ：IPv6 地址的首选生存期</li></ul><h3 id="3-使用实例-IP管理">3.使用实例-IP管理</h3><ul><li><p>命令： <code>ip addr add 192.168.0.123/24 dev eth0</code></p><p>说明：设置 IP</p></li><li><p>命令： <code>ip add del 192.168.0.123/24 dev eth0</code></p><p>说明：删除配置的 IP</p></li></ul><h3 id="4-使用实例-启用-禁用网卡">4.使用实例-启用/禁用网卡</h3><ul><li><p>命令： <code>ip link set eth0 up</code></p><p>说明：启用被禁用的网卡</p></li><li><p>命令： <code>ip link set eth0 down</code></p><p>说明：禁用网卡</p></li></ul><h3 id="5-使用示例-路由配置">5.使用示例-路由配置</h3><ul><li><p>命令：<code>ip route show</code></p><p>说明：查看路由信息</p><pre><code>  输出：</code></pre></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default via 172.17.175.253 dev eth0</span><br><span class="line">169.254.0.0/16 dev eth0 scope link metric 1002</span><br><span class="line">172.17.160.0/20 dev eth0 proto kernel scope link src 172.17.169.20</span><br></pre></td></tr></table></figure><ul><li><p>输出内容第一条是默认的路由，我们可以根据我们的需要改动它</p></li><li><p><code>metric 1002</code> ：跳跃计数，确定网关的优先级，默认 20，数值越小优先级越高</p></li><li><p><code>proto kernel</code> ：该路由的协议，主要有 <code>redirect</code> ， <code>kernel</code> ， <code>boot</code> ， <code>static</code> ， <code>ra</code> 等，其中 <code>kernel</code> 指的是直接由核心判断自动设定</p></li><li><p>命令： <code>ip route get 119.75.216.20</code></p><p>说明：通过 IP 地址查询路由包从哪条路由来</p></li><li><p>命令： <code>ip route add default via 192.168.0.150/24</code></p><p>说明：所有的网络数据包都通过 192.168.0.150 来转发，而不是以前的默认路由</p></li><li><p>命令： <code>ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3</code></p><p>说明：修改特定网卡的默认路由</p></li><li><p>命令： <code>ip route del 172.17.160.0/20</code></p><p>说明：删除路由</p></li><li><p>命令： <code>ip route flush cache</code></p><p>说明：刷新路由表</p></li></ul><h3 id="6-使用实例-显示网络统计数据">6.使用实例-显示网络统计数据</h3><p>这个显示网络统计数据则是 ip 命令非常重要的一个功能，很多时候，我们都依靠该功能来进行排除网络故障。</p><ul><li><p>命令： <code>ip -s link</code></p><p>说明：显示所有网络接口的统计数据</p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast</span><br><span class="line">    361849729592 174114258 0       0       0       0</span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    361849729592 174114258 0       0       0       0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 00:16:3e:08:08:55 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast</span><br><span class="line">    32345193376 115901261 0       0       0       0</span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    139742200499 114451909 0       0       0       0</span><br></pre></td></tr></table></figure></li><li><p>输出重点内容详解：</p><ul><li><code>RX</code> ：表示接收</li><li><code>TX</code> ：表示发送</li><li><code>bytes</code> ：接收/发送的字节数</li><li><code>packets</code> ：接收/发送的包数</li><li><code>errors</code> ：接收/发送的带有错误的包总数</li><li><code>dropped</code> ：由于处理资源不足导致接收/发送的丢弃的包数</li><li><code>overrun</code> ：因接收溢出（环形缓冲区）导致丢失的包；通常如果接口溢出，则表示内核中存在严重问题，或者说服务器上该网络设备的处理设备太慢</li><li><code>mcast</code> ：接收到的多播包数</li><li><code>carrier</code> ：因数据链路错误导致发送失败的包数</li><li><code>collsns</code> ：因在网络上发送冲突而导致的失败数</li></ul></li><li><p>命令： <code>ip -s -s link ls eth0</code></p><p>说明：获取一个特定网络接口的信息；在网络接口名字后面添加选项 ls 即可。使用多个选项-s 会输出指定接口详细的信息；特别是在排除网络连接故障时，这会非常有用。</p><p>输出：</p><pre><code>       2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000           link/ether 00:16:3e:08:08:55 brd ff:ff:ff:ff:ff:ff           RX: bytes  packets  errors  dropped overrun mcast           32469801665 116402997 0       0       0       0           RX errors: length   crc     frame   fifo    missed                      0        0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns           140235841575 115066014 0       0       0       0           TX errors: aborted  fifo   window heartbeat transns                      0        0       0       0       2</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS/岛屿问题/橘子问题/迷宫问题全解</title>
      <link href="/2022/04/10/k_%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3/"/>
      <url>/2022/04/10/k_%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>岛屿问题/橘子问题/DFS/迷宫问题其实都是一类问题，基本都可以用DFS搞定，这里先给出标准模板，再针对不同的题目给出相应的变动解。</p><h2 id="模板">模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS函数体模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>; <span class="comment">// 等于0相当于防止回头</span></span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待解函数体模板</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xxxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿问题">岛屿问题</h2><h3 id="1-岛屿最大的面积">1.岛屿最大的面积</h3><h5 id="695-岛屿的最大面积https-leetcode-cn-com-problems-max-area-of-island">695. 岛屿的最大面积https://leetcode-cn.com/problems/max-area-of-island/</h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220409150704.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        area += <span class="built_in">getArea</span>(grid, next_x, next_y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            maxnum = <span class="built_in">max</span>(maxnum, <span class="built_in">getArea</span>(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-飞地的数量">2.飞地的数量</h3><h5 id="1020-飞地的数量-https-leetcode-cn-com-problems-number-of-enclaves">1020. 飞地的数量 <a href="https://leetcode-cn.com/problems/number-of-enclaves/">https://leetcode-cn.com/problems/number-of-enclaves/</a></h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220409153720.png" alt=""></p><blockquote><p>本题的思路在于，从边界出发，将与边界相邻的陆地全部标记为1，那么之后，再对内部地区进行遍历，遇到1就++。思路还是很清晰的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, next_x, next_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从边界出发，将与边界相邻的所有能达到陆地都标记为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>); <span class="comment">// 左边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, n - <span class="number">1</span>);<span class="comment">// 右边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, <span class="number">0</span>, j); <span class="comment">// 上边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, m - <span class="number">1</span>, j);<span class="comment">// 下边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历寻找飞地</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++; <span class="comment">// 直接++就行了，相当于求面积了，ans的数目就是面积的数目</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-岛屿的数量">3.岛屿的数量</h3><h5 id="200-岛屿数量-https-leetcode-cn-com-problems-number-of-islands">200. 岛屿数量 <a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220409154713.png" alt=""></p><blockquote><p>注意，这道题目是TM的char，小心这个坑！</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, next_x, next_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-统计封闭岛屿的数目">4.统计封闭岛屿的数目</h3><h5 id="1254-统计封闭岛屿的数目-https-leetcode-cn-com-problems-number-of-closed-islands">1254. 统计封闭岛屿的数目 <a href="https://leetcode-cn.com/problems/number-of-closed-islands/">https://leetcode-cn.com/problems/number-of-closed-islands/</a></h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220409160823.png" alt=""></p><blockquote><p>这道题目其实就是飞地的数量 + 岛屿的数量，也就是前两道题目的综合</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, next_x, next_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从边界出发，将与边界相邻的所有能达到陆地都标记为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, <span class="number">0</span>); <span class="comment">// 左边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, n - <span class="number">1</span>);<span class="comment">// 右边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, <span class="number">0</span>, j); <span class="comment">// 上边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, m - <span class="number">1</span>, j);<span class="comment">// 下边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-被围绕的区域">5.被围绕的区域</h3><h5 id="130-被围绕的区域-https-leetcode-cn-com-problems-surrounded-regions">130. 被围绕的区域 <a href="https://leetcode-cn.com/problems/surrounded-regions/">https://leetcode-cn.com/problems/surrounded-regions/</a></h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220409171700.png" alt=""></p><blockquote><p>本题要将非边界的且被X环绕的O 变成X。O一共有三种，边界上的，被X环绕的，没被X环绕又不在边界的</p><p>注意到题目解释中提到：任何边界上的 O 都不会被填充为 X。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上</p><p>Step1: 利用DFS将边界上出发的O全部染色为N，剩下的没有被染色的O就是被X环绕的</p><p>Step2:遍历矩阵，遇到O就染色为X，遇到N就染色为O</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界都不能取到</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>()  || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()  || grid[x][y] == <span class="string">&#x27;X&#x27;</span> || grid[x][y] == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[x][y] = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_x = x + X[i];</span><br><span class="line">        <span class="keyword">int</span> next_y = y + Y[i];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, next_x, next_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">2</span> || n &lt;= <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从边界出发，将与边界相邻的所有能达到陆地都标记为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, i, <span class="number">0</span>); <span class="comment">// 左边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(board, i, n - <span class="number">1</span>);<span class="comment">// 右边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>, j); <span class="comment">// 上边界</span></span><br><span class="line">        <span class="built_in">dfs</span>(board, m - <span class="number">1</span>, j);<span class="comment">// 下边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 求职 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基本知识总结</title>
      <link href="/2022/04/06/k_Python%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/06/k_Python%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面经汇总">1 面经汇总</h2><p>链接：<a href="https://www.nowcoder.com/discuss/810095?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=7AF26494C293A69A98B7B13B743115D3-1648901123778">https://www.nowcoder.com/discuss/810095?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=7AF26494C293A69A98B7B13B743115D3-1648901123778</a></p><blockquote><p>1.python基础一定要熟练，常见数据类型，如何转换，面试了10多家，经常问到的基本就是列表和字典这两种，高级用法列表推导式等必须掌握</p><p>2.python可变对象，不可变对象</p><blockquote><p>可变：集合、字典和列表；不可变：数字、字符串和元组</p></blockquote><p>3.python深浅拷贝（基本100%问到）</p><p>4.python内存管理（内存池，垃圾回收机制，不了解的赶紧去查，高频）</p><p>5.python面向对象的常用方法，如<code>__new__</code>和<code>__init__</code>区别，<code>__call__</code>方法，<code>__str__</code>,以及如何调用父类（super），以及面向对象的特性，什么是面向对象，你如何理解的等等，这些务必掌握。因为这都是最基础的，只要你背了，看了，你就有竞争力！</p></blockquote><h2 id="2-知识点">2.知识点</h2><h5 id="1-python3中有6个标准的数据类型">1.python3中有6个标准的数据类型</h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220402155030.png" alt=""></p><h5 id="2-list-和dict有什么区别">2.list 和dict有什么区别</h5><blockquote><ul><li><p>list是有序的，dict是无序的</p></li><li><p>list通过索引访问，dict使用key访问</p></li><li><p>list随着数量的正常增长要想查找元素的时间复杂度为O(n), dict不随数量而增长而变化，时间复杂度都为O(1)</p><blockquote><p>有点随机访问的味道了，408学习的记忆，顺序存储的数组可以随机访问</p></blockquote></li><li><p>dict的占用内存稍比list大，会在1.5倍左右</p></li></ul><p>list一般可作为队列、堆栈使用，而dict一般作为聚合统计或者快速使用特征访问等<br>Tuple可以看做是一种“不变”的List，访问也是通过下标，用小括号（）表示</p></blockquote><h5 id="3-可更改与不可更改对象">3.可更改与不可更改对象</h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220403202821.png" alt=""></p><h5 id="4-加-表示参数会以元组-tuple-的形式导入，存放所有未命名的变量参数。">4.加<code>*</code>表示参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</h5><blockquote><p>不定长参数aka可变参数列表</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220403205445.png" alt=""></p><h5 id="5-面向对象，继承">5.面向对象，继承</h5><blockquote><ul><li>self代表实例，不是类。类函数里必须有一个额外的参数，默认self</li></ul><ul><li>若父类方法功能不能满足要求，可以再子类重写父类方法。使用super(子类名,子类对象).func()调用父类方法</li><li>类内属性加两个下划线开头，表示属性私有，不能再类外被直接使用或者访问</li></ul><blockquote><p>变量名以两个下划线__开头，表示私有成员，外部不能访问， <strong>需要自定义访问函数才可以访问</strong>。一个下划线表示：虽然可以被外部访问，但不要随意访问</p></blockquote></blockquote><blockquote><p><code>__new__</code>和<code>__init__</code>区别:</p><p>实际上，<code>__init__</code>函数并不是真正意义上的构造函数，<code>__init__</code>方法做的事情是在对象创建好之后初始化变量。真正创建实例的是<code>__new__</code>方法</p><blockquote><p>new是买材料准备沙子水泥砖头，init就是直接用这些材料盖房子。<code>__new__</code>方法会返回创建的实例，而<code>__init__</code>什么都不返回</p></blockquote><p>也就是说new + init才是构造函数，new是静态方法，用来创建实例；而init是实例方法，用来初始化变量</p></blockquote><blockquote><p><code>__call__</code>方法，定义在类中，将对象变成可调用的对象，从而表现得像个函数。简单来说，就把对象当成方法来使用</p><blockquote><p>有的人明明是对象却活成了方法</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220410160011.png" alt=""></p></blockquote></blockquote><h5 id="6-多线程，GIL">6. 多线程，GIL</h5><blockquote><p>python为了保证线程的安全而采取的独立线程运行的限制<strong>一个核只能在同一时间运行一个线程</strong></p><blockquote><p>不过你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转</p></blockquote><p><strong>对于IO密集的任务可以采用多线程操作，而对于cpu密集的任务(科学计算程序和机器学习程序等)，应该采用多进程</strong>，如果此时用多线程有可能因为争夺资源而变慢</p><blockquote><p>对于面向I/O的程序来说，里面一个进程A在I/O调用前，会释放掉GIL，其它线程在线程A等待I/O的时候运行</p></blockquote><p>GIL就像通行证，拿到之后，才能上CPU运行。<strong>并且由于GIL的存在，python里一个进程永远只能同时执行一个线程（拿到GIL的线程才能执行），这就是为啥在多核cpu上，python的多线程效率并不高的原因</strong></p></blockquote><p>总结一下：</p><blockquote><p>Python的多线程是伪的多线程，单位时间多个核只能跑一个线程</p><p><strong>多核下，想做并行提升效率，比较通用的方法是使用多进程，能够有效提高执行效率</strong></p></blockquote><p>---------------------------------分割线------------------------------</p><p>几个概念</p><blockquote><p>同步：多个程序之间执行有先后顺序，依个执行完下个才能执行</p><p>异步：多个程序之间没有先后顺序，可以同时执行，有时候一个任务可能在必要的时候获取另一个同时执行的任务的结果，这叫回调</p></blockquote><p>几个进程概念</p><blockquote><p>孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程</p><p>僵尸进程： <strong>进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程</strong></p></blockquote><p>---------------------------------分割线------------------------------</p><p><strong>线程池</strong></p><blockquote><p>线程池是一种空间换时间的策略</p></blockquote><blockquote><p>如果运行的程序需要频繁将任务派发给线程执行，就需要线程池。因为频繁的创建、释放线程会涉及到大量的底层操作，开销较大。如果能在应用程序工作期间，完成一些预创建进程和借还的操作，将大大提高CPU的利用率。</p></blockquote><blockquote><p>线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于就绪状态，不会消耗CPU资源，但会占用少量的内存空间。</p></blockquote><blockquote><p>一般线程池必须具备下面几个组成部分</p><p>1.线程池管理器</p><p>2.工作线程和线程队列</p><p>3…</p><p>4…</p></blockquote><h5 id="7-装饰器">7.装饰器</h5><p><strong>概念</strong></p><blockquote><p>概括的讲， <strong>装饰器的作用就是为已经存在的函数或对象添加额外的功能</strong> ，丰富原有函数的功能，使之变得更加强大。引入装饰器，便于开发，便于代码复用。不必改动原有的任何的代码，即可增加新的功能。</p></blockquote><p><strong>功能</strong></p><blockquote><p>1.可以在一个函数上使用多个装饰器，顺序由前到后</p><p>2.装饰器可以修饰函数，也可以修饰类</p></blockquote><blockquote><p>在一些需要重复使用某些操作的场景中，可以使用装饰器。eg：计算函数运行时间（如果为不同的函数设置不同的计算时间的函数，就太累了），再eg：给函数打印日志。。。</p></blockquote><p><strong>其它补充</strong></p><blockquote><p>下面的例子中，函数中再定义一个函数的操作叫做闭包。<strong>内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。闭包具有提高代码复用性的作用</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warp</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;a&gt;&quot;</span>+fn()+<span class="string">&quot;&lt;a&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warp</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;b&gt;&quot;</span>+fn()+<span class="string">&quot;&lt;b&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> warp</span><br><span class="line"><span class="meta">@makebold         </span><span class="comment">#这句话相当于makebold(test1),也就是把当前函数传过去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test1&quot;</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test2&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>():</span>     <span class="comment">#函数和装饰器是倒着执行的，从下往上，相当于makeold(makeitalic(test3))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test3&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(test1())</span><br><span class="line"><span class="built_in">print</span>(test2())</span><br><span class="line"><span class="built_in">print</span>(test3())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;test1&lt;a&gt;</span><br><span class="line">&lt;b&gt;test2&lt;b&gt;</span><br><span class="line">&lt;a&gt;&lt;b&gt;test3&lt;b&gt;&lt;a&gt;</span><br></pre></td></tr></table></figure><h5 id="8-浅拷贝和深拷贝">8.浅拷贝和深拷贝</h5><blockquote><p>浅拷贝：将对象本身的引用复制给了新的对象，但是包含的子对象还是和之前一样的</p><p>深拷贝：相当于增加了一块儿内存，把对象所有内容复制一遍</p></blockquote><blockquote><p>用一个例子来说明</p><p>直观来看，等号赋值操作，直接就是传对象的引用，引用数++；</p><p>而浅拷贝，a对象本身的修改没能传到，但是子对象的修改传到了。说明对象本身的引用复制给了新的对象，但是包含的子对象还是和之前一样的</p><p>而深拷贝就是全新的对象了，和之前无关了，看第二张图</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220408224712.png" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220408225029.png" alt=""></p></blockquote><h5 id="9-内存管理">9.内存管理</h5><p><a href="https://andrewpqc.github.io/2018/10/08/python-memory-management/">https://andrewpqc.github.io/2018/10/08/python-memory-management/</a></p><p><strong>引用计数</strong></p><blockquote><h5 id="1-概念">1.概念</h5><p>Python中，主要通过**引用计数（Reference Counting）**进行垃圾回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct_object &#123;</span><br><span class="line">    <span class="built_in">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>在Python中每一个对象的核心就是一个结构体<code>PyObject</code>，它的内部有一个引用计数器（<code>ob_refcnt</code>）。</p><p>当有一个新的引用的时候，<code>ob_refcnt</code>的值会增加</p><blockquote><p>对象被创建；对象被引用；对象被作为参数，传入到一个函数中</p></blockquote><p>当引用它的对象被删除，<code>ob_refcnt</code>的值会减少</p><blockquote><p>对象别名被显示销毁 del；一个对象离开他的作用域；</p></blockquote><h5 id="2-优缺点">2.优缺点</h5><p>优点：逻辑简单、实时</p><p>缺点：维护引用计数需要资源； 循环应用难顶（引用计数无解）</p></blockquote><p><strong>标记清除</strong></p><blockquote><p><strong>解决引用计数中存在的循环引用的问题</strong></p></blockquote><blockquote><p>step1:<strong>标记阶段：</strong> 遍历以对象为节点、以引用为边构成的图，标记所有可访问的对象</p><p>step2：<strong>清除阶段</strong>：再次遍历，发现某个对象未被标记，就回收</p></blockquote><p><strong>分代回收</strong></p><blockquote><p>空间换时间的方法，来提高垃圾回收的效率</p></blockquote><blockquote><p>对于程序，存在有的的内存块的生存周期比较短，而有的比较长。存在时间越长的就越不可能是垃圾，就应该越少收集，可以有效减少标记清除阶段遍历的对象数，从而提高回收速度。</p><p>分代回收的本质就是将不同生存周期的内存块划分为不同的集合。每个集合就是一个“代”</p><blockquote><p>Python默认定义了三代对象集合，索引数越大，对象存货时间越长</p></blockquote></blockquote><h5 id="10-with关键字的用法">10. with关键字的用法</h5><blockquote><p>with语句实质上是一个上下文管理器，with语句后的对象都有<code>__enter__()</code>和<code>__exit__()</code>方法。进入上下文的时候调用enter方法，而程序执行完成/出现异常则调用exit方法</p></blockquote><blockquote><p>naive版本的硬打开关闭没能实现异常处理。eg open并write了，但是种种原因，没有close，那么就会导致资源一直被占用</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220405154833.png" alt=""></p></blockquote><blockquote><p>而进阶版的，可以手动通过try/except/finally语句来规避风险</p><p>try执行有问题，就转而执行except，而finally是一定会执行的，也就是说close一定会有的，就不会出现前面提到的问题了。</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220405155107.png" alt=""></p></blockquote><h5 id="11-Python中的作用域">11. Python中的作用域</h5><blockquote><p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p></blockquote><h5 id="12-Python常用的框架">12.Python常用的框架</h5><blockquote><p>Django框架；Flask框架；Tornado框架</p><p>这三个都是Web的框架</p><p>FastApi站在Flask框架上的</p></blockquote><h5 id="13-lambda函数-匿名函数">13. lambda函数/匿名函数</h5><blockquote><p>直观来看，使得代码更加简洁；对于一些不那么容易命名的操作，使用lambda可以直接避开</p></blockquote><h5 id="14-Python执行原理">14.Python执行原理</h5><blockquote><p><strong>c++:</strong> c++是编译性语言编写的程序，从源文件转换成计算机使用的机器语言，经过链接器之后形成了二进制的可执行文件。运行程序的时候，把二进制程序从硬盘载入到内存中并运行</p><p><strong>Python</strong>：Python解释器将源代码转换为字节码，然后再由python解释器来执行这些字节码</p><blockquote><p>1.python运行时通常要转换为字节码，再由虚拟机把字节码转换成机器语言，最后才能在硬件上运行。但是，python并不是每次都需要转换字节码，解释器在转换之前会判断代码文件的修改时间是否与上一次转换后的字节码pyc文件的修改时间一致，若不一致才会重新转换</p><p>2.python程序员不用关心程序的编译和库的链接，开发更轻松</p><p>3.python代码与机器底层更远了，移植性更强了</p></blockquote></blockquote><h5 id="15-实例方法-静态方法-类方法">15.实例方法/静态方法/类方法</h5><blockquote><p>**实例方法：**第一个参数必须是实例对象，一般约定self，通过实例方法来传递实例的属性和方法(类也可)。但是只能由实例对象调用。<strong>简而言之，实例方法就是类的实例能够使用的方法</strong></p></blockquote><blockquote><p>**类方法：**使用装饰器@classmethod，原则上，类方法是将类本身作为对象进行操作的方法。也就是把格局打开，把类（更大）作为对象来操作。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法。实例对象和类对象都可以调用</p></blockquote><blockquote><p>**静态方法：**使用装饰器@staticmethod，静态方法是类中的函数，不需要实例。也就是说它只是类中一个普普通通的函数，和类中没有关系，放在类外边也能够实现。但是放在类外边，可能会打乱逻辑关系，导致代码后期维护困难。</p></blockquote><h5 id="16-迭代器与生成器">16.迭代器与生成器</h5><p>大佬的博客：<a href="https://segmentfault.com/a/1190000023187334">https://segmentfault.com/a/1190000023187334</a></p><p><strong>迭代器</strong></p><blockquote><p>迭代器是实现了迭代器协议/具有迭代功能的对象。Python语言中并没有用于定义协议或表示约定的关键字，而是使用魔法方法来表示约定。<code>__next__</code>和<code>__iter__</code>这两个魔法方法就代表了迭代器协议</p></blockquote><blockquote><p>一个迭代器对象只能迭代一遍。多次迭代，相当于不停对一个空迭代器调用next方法，会不停raise StopIteration异常。</p><p>由于迭代器实现了iter方法，并且iter方法返回了迭代器，那么迭代器也是一个可迭代对象</p><p><strong>综上来说，可迭代对象和迭代器明显是一个多态的问题。</strong></p><p><strong>迭代器</strong>是一个可迭代对象，可以迭代返回元素，由于iter返回self(即自身实例)，所以<strong>只能迭代一遍，迭代到末尾就会抛出异常。</strong></p><p>而每次迭代<strong>可迭代对象</strong>，iter都会<strong>返回</strong>一个<strong>新的迭代器实例</strong>。所以可迭代对象是<strong>支持多次迭代</strong>的。</p><p>比如<code>l=[i for i in range(10)]</code>生成的list对象就是一个可迭代对象，可以被多次迭代。</p><p><code>l=(i for i in range(10))</code>生成的是一个迭代器，只能被迭代一遍。</p></blockquote><p><strong>生成器</strong></p><blockquote><p>生成器函数就是含有yield关键字的函数</p><p>每次调用生成器函数会返回一个新的生成器对象</p><blockquote><p>生成器对象和迭代器对象相似，都可以被for循环迭代，都只能被迭代一遍，通过next调用，都会在生成器元素为空时raise一个StopIteration异常</p></blockquote><p><code>yield</code>具有暂停的功能，每次迭代生成器，生成器函数体都会前进到yield语句处，并将yield之后的值抛出(无值抛None)。</p><blockquote><p>生成器函数作为一个工厂函数，实现了可迭代对象中iter函数的功能，可以每次产出一个新的迭代器实例。由于使用了特殊的yield关键字，它拥有与区别于迭代器的新名字——生成器，它其实与迭代器并无二致</p></blockquote></blockquote><blockquote><p>生成器表达式（AKA生成式）：<code>(i for i in range(10))</code>,也就是列表推导式的方括号变成了圆括号</p></blockquote><h5 id="17-Python解释器">17.Python解释器</h5><blockquote><p>CPython，官方提供的使用C语言实现的解释器，在命令行下运行<code>python</code>来启动解释器</p><p>使用<code>&gt;&gt;&gt;</code>作为提示符</p></blockquote><blockquote><p>IPython，基于CPython之上的一种，交互式解释器，交互方式有所增强。例如Anaconda下面的Jupyter Nodebook就是这个。</p><p>使用<code>In [序号]：</code>作为提示符</p></blockquote><h5 id="18-函数参数-arg和-kwargs分别代表什么？">18 函数参数<code>*arg</code>和<code>**kwargs</code>分别代表什么？</h5><blockquote><p><code>*arg</code>是可变参数，可接受0个或多个参数，当传入的参数数目不确定时，用它。<strong>它将传入的参数打包成为元组</strong></p><p><code>**kwargs</code>代表关键字参数，接收用<code>参数名=参数值</code>的方式传入的参数，<strong>传入的参数打包成为字典</strong></p></blockquote><h5 id="19-鸭子类型">19.鸭子类型</h5><blockquote><p>鸭子类型是动态类型语言判断一个对象是不是某种类型时使用的方法。也就是说如果对象的行为更我们预期的对象行为一致，我们就可以认为它是这种类型的对象</p></blockquote><blockquote><p>举个栗子，Python 的迭代器协议就包含 <code>__iter__</code> 和 <code>__next__</code> 两个方法，任何实现了 <code>__iter__</code> 和 <code>__next__</code> 方法的类，Python 解释器会将其视为迭代器</p></blockquote><blockquote><p>在面向对象的编程中，协议是非正式的接口，只在文档中定义，不在代码中定义，可以看成是约定俗称的习惯。</p></blockquote><h5 id="20-闭包">20.闭包</h5><blockquote><p>闭包就是能够读取外部函数内的变量的函数</p><p>闭包是将外层函数内的局部变量和外层函数的外部连接起来的一座桥梁</p><p>将外层函数的变量持久地保存在内存中</p><blockquote><p>函数的局部变量在函数调用结束之后就结束了生命周期，但是<strong>闭包使得局部变量的生命周期得到了延展</strong></p></blockquote></blockquote><h5 id="21-猴子补丁、">21.猴子补丁、</h5><blockquote><p>猴子补丁可以视为热补丁，代码运行的时候，在不修改源代码的前提下，改变代码中的方法、属性等等。</p></blockquote><h5 id="22-编码规范">22.编码规范</h5><p>PEP8</p><blockquote><p>使用空格来表示缩进</p></blockquote><h5 id="x-其它的">x.其它的</h5><ol><li></li></ol><blockquote><p>try, except, finally。捕获异常，若try发生异常，则执行except内容，无论是否产生异常，finally都会执行</p><p>断言assert(),断言成功，程序继续执行，断言失败，程序报错</p></blockquote><ol start="2"><li></li></ol><blockquote><p><strong>python是值传递还是引用传递</strong>：python不允许程序员选择采用传值还是传引用。python参数传递采用的是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值–相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字，字符或者元组）的引用，就不能直接修改原始对象–相当于通过“传值”来传递对象。</p></blockquote><ol start="3"><li></li></ol><blockquote><p><code>__name__=='__main__'</code>的所用是什么</p><ul><li><strong>当.py文件执行时，main下面的代码执行</strong></li><li><strong>当.py文件被其他文件引用时，main下面的代码不执行</strong></li></ul></blockquote><p>4.列表和元组的区别</p><blockquote><p>列表是动态数组，可变且可以重设长度，使用方括号创建。Python的列表第一次增加数据的时候，不是严格按照+n去增加空间的，而是会给未来可能的增加<strong>预留</strong>更多的<strong>空间</strong>，也就是说第一次添加可能是后续多次添加的开始。通过预留空间，可以减少分配空间的操作次数和内存复制的次数。</p></blockquote><blockquote><p>元组是静态数组，不可变，使用圆括号来创建。</p></blockquote><blockquote><p><strong>执行效率</strong>：<strong>元组的生成速度比列表快很多，迭代速度快一点，索引速度差不多</strong></p><blockquote><p>迭代就是类似于for循环取值</p></blockquote></blockquote><p>5.Python没有函数重载</p><blockquote><p>函数重载是指同一个作用域有多个同名的函数，它们拥有不同的参数列表</p><p>Python是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。</p><p>再者Python中函数的参数可以有默认值，可以使用<strong>可变参数</strong>和<strong>关键字参数</strong>，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为</p></blockquote><p>6.使用过的模块</p><blockquote><p>OS：指定模型训练保存权重位置</p><p>Torch：Pytorch</p><p>numpy：常用的数据运算吗，切片索引什么的</p><p>pandas：数据清洗，CSV，json文件。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 求职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/31/k_%E7%AC%94%E8%AF%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/03/31/k_%E7%AC%94%E8%AF%95%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">title: 代码模板</span><br><span class="line">tags: </span><br><span class="line">  - 求职</span><br><span class="line">  - c++</span><br><span class="line">categories: 求职</span><br><span class="line">description: c++</span><br><span class="line"></span><br><span class="line">copyright_author: Jlthzy</span><br><span class="line">copyright_author_href: https://newblog.leohu.me</span><br><span class="line">copyright_url: https://newblog.leohu.me</span><br><span class="line">copyright_info: 此文章版权归Jlthzy所有，如有转载，请注明原作者</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯法标准模板</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();<span class="comment">// 回溯，撤回处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长回文子串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongestPalindrome</span><span class="params">(string A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = A.<span class="built_in">size</span>(),ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> size;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">2</span> &amp;&amp; A[<span class="number">0</span>] != A[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(size, vector&lt;<span class="keyword">int</span>&gt; (size,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="number">2</span>;<span class="comment">//当前回文字符串的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="comment">// 上面的循环已经将长度为1和2的dp值求了出来</span></span><br><span class="line">    <span class="comment">// 下面一次增加值，求出所有的dp值，就避免了遇到没有初始化的dp值的问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">3</span>; k &lt;= size; k++) &#123;<span class="comment">//枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; size; i++) &#123;<span class="comment">//枚举子串的起始端点</span></span><br><span class="line">            <span class="keyword">int</span> j = i + k - <span class="number">1</span>;<span class="comment">//子串的右端点</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] == A[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = k;<span class="comment">//更新回文字符串的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, minlen = INT_MAX;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; windows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : T) need[i]++;</span><br><span class="line">    <span class="keyword">int</span> match = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &lt; S.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> k = S[right];</span><br><span class="line">        <span class="comment">//元素S[i]在need数组中存在</span></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(k)) &#123;</span><br><span class="line">            <span class="comment">// windows[k]先++</span></span><br><span class="line">            windows[k]++;</span><br><span class="line">            <span class="comment">// 这是考虑到同一个字符元素可能用多个的情况，例如T中有两个a</span></span><br><span class="line">            <span class="keyword">if</span>(windows[k] == need[k]) match++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(match == need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; minlen)&#123;</span><br><span class="line">                minlen = right - left;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> m = S[left];</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(m)) &#123;</span><br><span class="line">                windows[m]--;</span><br><span class="line">                <span class="keyword">if</span>(windows[m] &lt; need[m]) match--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minlen == INT_MAX ? <span class="string">&quot;&quot;</span> : S.<span class="built_in">substr</span>(start, minlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次遍历模板</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">    <span class="comment">//当队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* tempnode = que.<span class="built_in">front</span>();<span class="comment">//读取头部节点</span></span><br><span class="line">            que.<span class="built_in">pop</span>();<span class="comment">//弹出头部节点</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(tempnode-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tempnode-&gt;left) que.<span class="built_in">push</span>(tempnode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tempnode-&gt;right) que.<span class="built_in">push</span>(tempnode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">埃氏筛</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迷宫问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; paths)</span></span>&#123;</span><br><span class="line">    paths.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i, j)); <span class="comment">//记入路径</span></span><br><span class="line">    matrix[i][j] = <span class="number">1</span>; <span class="comment">//经过部分设置为1，表示后续不能经过</span></span><br><span class="line">    <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; j == m - <span class="number">1</span>)&#123; <span class="comment">//到达终点</span></span><br><span class="line">        res = paths;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//四个方向搜索</span></span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; matrix[i + <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, n, m, i + <span class="number">1</span>, j, paths);</span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; m &amp;&amp; matrix[i][j + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, n, m, i, j + <span class="number">1</span>, paths);</span><br><span class="line">    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, n, m, i - <span class="number">1</span>, j, paths);</span><br><span class="line">    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(matrix, n, m, i, j - <span class="number">1</span>, paths);</span><br><span class="line">    paths.<span class="built_in">pop_back</span>(); <span class="comment">//回溯</span></span><br><span class="line">    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">matrix</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) <span class="comment">//输入迷宫矩阵</span></span><br><span class="line">                cin &gt;&gt; matrix[i][j];</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; paths; <span class="comment">//记录临时路径</span></span><br><span class="line">            <span class="built_in">dfs</span>(matrix, n, m, <span class="number">0</span>, <span class="number">0</span>, paths); <span class="comment">//dfs遍历矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) <span class="comment">//输出路径</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; res[i].first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; res[i].second &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; neighbors;</span><br><span class="line">                    neighbors.<span class="built_in">push</span>(&#123;r, c&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (!neighbors.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> rc = neighbors.<span class="built_in">front</span>();</span><br><span class="line">                        neighbors.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                        <span class="keyword">if</span> (row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            neighbors.<span class="built_in">push</span>(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                            grid[row<span class="number">-1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            neighbors.<span class="built_in">push</span>(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                            grid[row+<span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            neighbors.<span class="built_in">push</span>(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                            grid[row][col<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            neighbors.<span class="built_in">push</span>(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                            grid[row][col+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题完全理解</title>
      <link href="/2022/03/31/k_DP%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/03/31/k_DP%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="背包的重量和价值如下所示">背包的重量和价值如下所示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> bagweight = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h4 id="二维01背包">二维01背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bagProblem</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weight, vector&lt;<span class="keyword">int</span>&gt; value, <span class="keyword">int</span> bagweight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二维dp数组并且初始化为0</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt; (bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 第一行初始化,只要当背包放得下0号物品，才有价值的意义</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = weight[<span class="number">0</span>]; i &lt;= bagweight; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历dp背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123;</span><br><span class="line">            <span class="comment">// 背包容量放不下物品i</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 放得下</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维01背包">一维01背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bagProblem</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weight, vector&lt;<span class="keyword">int</span>&gt; value, <span class="keyword">int</span> bagweight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]表示容量为i的背包所含有的最大价值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagweight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 容量为空的背包，显然不值钱</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历dp背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = bagweight; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagweight] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一维背包问题，第二个for循环的j要从<code>bagweight</code>倒着遍历回去是因为</p><p>如果正着来，物品被放入了两次</p><blockquote><p>eg: 当i = 0的时候，weight[0] = 1，价值value[0] = 15</p><p><code>dp[1] = dp[1 - weight[0]] + value[0] = 15</code></p><p><code>dp[2] = dp[2 - weight[0]] + value[0] = 30</code></p></blockquote><p>那，倒着来，为啥行呢？so easy</p><blockquote><p>dp数组初始化，所有元素的值都为0，那么 当i = 0的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">2</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>]) </span><br><span class="line">  = <span class="built_in">max</span>(<span class="number">0</span>, dp[<span class="number">1</span>] + value[<span class="number">0</span>]) </span><br><span class="line">  = value[<span class="number">0</span>]  </span><br><span class="line">  = <span class="number">15</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">1</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>])</span><br><span class="line">  = <span class="built_in">max</span>(<span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">  = <span class="number">15</span></span><br></pre></td></tr></table></figure></blockquote><p>那为什么二维背包可以不用逆着过来，可以计算表格来分析，本层的<code>dp[i][j]</code>完全来自上层，不存在多次计算的情况，很容易理解。</p><hr><h3 id="完全背包">完全背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> bagweight = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>上面提到，01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220328213145.png" alt=""></p><p>所以完全背包的完整Code如下👇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bagProblem</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; weight, vector&lt;<span class="keyword">int</span>&gt; value, <span class="keyword">int</span> bagweight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]表示容量为i的背包所含有的最大价值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagweight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 容量为空的背包，显然不值钱</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历dp背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagweight] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 求职 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 求职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通道注意力机制 SEnet/ECAnet</title>
      <link href="/2022/03/20/f_%E9%80%9A%E9%81%93%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6SE&amp;ECA/"/>
      <url>/2022/03/20/f_%E9%80%9A%E9%81%93%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6SE&amp;ECA/</url>
      
        <content type="html"><![CDATA[<h1>1.SEnet</h1><h2 id="0-引言和相关工作">0.引言和相关工作</h2><p>SEnet是2017年同时也是ImageNet大规模分类竞赛最后一届的冠军，算是在CV中引入通道注意力机制的代表作之一，整篇文章读下来，很有感受，作者真的是在走心在写文章，相较于一些论文靠直觉写文章(此处点名某inception)，作者在SEnet中的参数设定，结构设计都是有实验做支撑的，很棒的一篇文章。</p><p>SEnet核心在于使用“特征重标定”的策略来显式的建模特征通道之间的相互依赖关系，通过学习方式来自动获取每个特征通道的重要程度，提升有用的特征，抑制没用的特征</p><p>SEnet的模型思路很清晰</p><blockquote><p>1.通过常规的卷积操作将feature map常宽深变到<code>H*W*C</code></p><p>2.通过GAP，将上层feature map变成<code>1*1*C</code>的长向量</p><p>3.将上一步长向量输入FC-&gt;ReLU-&gt;FC-&gt;Sigmoid，最后的输出依然是<code>1*1*C</code>的元素值在0~1之间的长向量权重</p><p>4.Reweight，将权重乘上原来的<code>H*W*C</code>的feature map，完成关注</p></blockquote><p>SEnet模块在不同的深度扮演的角色是不同的</p><blockquote><p>在浅层的神经网络，SEnet起到的是增强共享的低级别表征的作用。我的理解是，浅层神经网络提取到的是纹理、形状、颜色等普适性的特征，这些特征是不能起到区分类别作用的，因此SEnet就通过注意来增强这类的表达</p><p>在深层的神经网络，SEnet的表现就很特化了，针对不同的类别，所起到的作用所关注的点就不同了。我的理解是深层的CNN提取到的是特化稠密的语义信息，已经能够起到一定的分类作用了。</p></blockquote><p>SEnet模块是普适性的，一是可以用在多个SOTA模型上(2017年的)，只需要增加极少数的计算量，就能收获不错的性能增益；二是可以用在ImageNet之外的数据集上，并且也表现出不俗的性能。</p><h2 id="1-论文核心内容">1.论文核心内容</h2><h3 id="1-1-SE模块结构">1.1 SE模块结构</h3><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318194935.png"/><h4 id="Ftr操作">Ftr操作</h4><p>就下图这个公式，看起来很复杂的样子，其实就是一个常规卷积。我自己的理解是，作者后续的思路都建立在CxHxW的feature map上，这一步相当于是对不同长宽通道数的feature map做了个归一化，方面后面的统一处理</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318195314.png"/><h4 id="Squeeze操作-Fsq">Squeeze操作(Fsq)</h4><p>其实就是全局平均池化操作，将原来的feature map拉平成一个1x1xC的长向量</p><blockquote><p>作者一开始是想每个通道都使用一个卷积核来提取特征，但这样很难做到跨通道信息交融。</p><blockquote><p>小声BB，这他妈不就是Depthwise卷积吗？</p></blockquote><p>作者偷了个懒，想用最简单的方式来完成全局的特征提取，用GAP是很简单的，用其它复杂的也可以。SE模块本身就增加了额外的计算量，如果再用复杂的，就不经济了。</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318195747.png" alt=""></p><h4 id="Excitation操作-Fex">Excitation操作(Fex)</h4><p>为了限制模型复杂度和辅助泛化，论文通过引入FC-&gt;ReLU-&gt;FC</p><p>第一个Fc层降维，经过Relu非线性激活之后，第二个FC升维到原来的像素空间，最后经过sigmoid函数将通道的值压缩到0~1之间，表示权重。</p><blockquote><p>作者认为Excitation操作是一种通道层面上的Self-Attention(得益于FC层)，而不像卷积核只有局部感受野</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318200156.png" alt=""></p><h4 id="4-Reweight">4.Reweight</h4><p>就是将上一步得到的权重乘上通道，表示attention</p><hr><h3 id="1-2模型和计算复杂度">1.2模型和计算复杂度</h3><h4 id="a-计算">a.计算</h4><p>作者认为，将SE实践应用前，应当要先做到性能提升和计算复杂度提升的平衡。作者先在ResNet50和SE-ResNet50上边做了实验。输入一张224*224像素的图像，ResNet50经过了<code>~3.86GFLOPs</code>，而SE-ResNet50则是<code>~3.87GFLOPs</code>，增加了0.26%</p><blockquote><p>注意，这里的SE-ResNet50是在<code>Reduction Ratio=16</code>的情况下测试的</p><p>SE的耗时增加主要在squeeze、excitation以及scaling(也就是Reweight)</p></blockquote><p>作者还将这两个模型在GPU和CPU上的推理时间做了对比，<strong>作者认为，额外的增加一点点开销，换来模型的性能的增加，这种操作是合理的</strong></p><h4 id="b-参数">b.参数</h4><p>SE-ResNet50在参数上比ResNet50多<code>~2.5million</code>,比ResNet50多了10%(ResNet50有<code>~25million</code>)但这部分多出的参数主要来自ResNet50最后阶段，通道数太多了</p><blockquote><p>看到2048没？</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220319235159.png" alt=""></p></blockquote><p><strong>作者实验发现，最后一层的SE模块是可以去掉的</strong>，去掉之后，imagenet上的top5错误率降低&lt;0.1%，But，额外的参数却减少到4%。 因此，<strong>在Care参数量的case中，这种做法是很棒的</strong></p><hr><h3 id="1-3实验">1.3实验</h3><p>这一板块，我只看了ImageNet上的实验</p><h4 id="a-Network-depth">a. Network depth</h4><p>因为实验的设备和这些原始论文的环境不同，作者还特意重跑了一次，走心了。</p><p>从下图来看，SE模块对于模型性能的提升的显然的。横向来看SE-ResNet50在top5上的错误率低于ResNet50；纵向来看，SE-ResNet101的top5错误率是低于ResNet152的，浮点运算可减少了很多噢</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320000722.png" alt=""></p><h4 id="b-Integration-with-modern-architectures">b. Integration with modern architectures</h4><p>这一小块主要就是SE模块和2017年的SOTA融合，实验结果可以看上面这张图表2。</p><p>这里再贴一张，SEnet持续改善，且在多个网络中都有正向的作用，都提升了网络的性能，这证明了SE模块的普适性。写到这里，不得不心疼下Label smoothing。</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320001642.png" alt=""></p><h4 id="c-Mobile-setting">c. Mobile setting</h4><p>作者在轻量级CNN上也做了实验，让我们一起高呼，MobileNet牛逼！SEnet牛逼！</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320001909.png" alt=""></p><h4 id="d-Additional-dataset">d. Additional dataset</h4><p>作者还在多个数据集上做了实验，再次证明了SE的普适性，并不是只适合于ImageNet</p><p>走心的作者，值得Respect！</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320002130.png" alt=""></p><hr><h3 id="1-4-Ablation-Studty-消融实验-AKA对照实验">1.4 Ablation Studty 消融实验(AKA对照实验)</h3><p><strong>这一板块作者通过实验详细的说明了1.1节中各种参数设置、网络模型设计的原因。没啥好说的，直接Respect！</strong></p><p><strong>同时这一节和下一节，也是我认为这篇论文中最有深度也是最难的部分，我也通过这两节间接想明白了很多问题</strong></p><h4 id="a-Reduction-ratio">a. Reduction ratio</h4><p>也就是1.1节中的r。作者手动设置r，进行了一系列的实验，主要有一下几点结论👇</p><blockquote><p><code>r=16</code>的时候，模型性能是最佳的</p><p><strong>SE模块是具有鲁棒性的</strong>，r从2变到32，top5错误率依然比原始版本的低</p><p><strong>不同的网络可能对应着不同的最优r，不能一概而论</strong></p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320002931.png" alt=""></p><h4 id="b-Squeeze-Operator">b. Squeeze Operator</h4><p>这一块很简单，主要是说明用GAP比用Max优秀</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320003408.png" alt=""></p><h4 id="c-Excitation-Operator">c. Excitation Operator</h4><p>这个应该是Excitation最后边那个激活函数，而不是两个FC之间的，因为下图中，sigmoid最优</p><p>这也说明了，要让SE高效，选择合适的Excitation 很重要。</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320003652.png" alt=""></p><h4 id="d-Different-stage">d. Different stage</h4><p>就是这个，全加是最好的。也可以这么认为，加在不同stage的SE模块是互补的，所以最后加一堆之后，就强强联手，优上加优。</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320004133.png" alt=""></p><h4 id="e-Integration-strategy">e. Integration strategy</h4><p>就是在不同的位置加SE模块。SE-PRE、SE-Identify以及SE结果相似，SE-POST不行</p><p>作者认为，SE对于位置还是有相对的鲁棒性的</p><blockquote><p>其实作者还尝试在ResNet残差内部加入SE模块，也就是在残差通道上加入SE，也就是直接在3x3卷积后边加入SE。But结果不好，作者认为，以后可以针对特别的结构，定制不同的SE模块</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320004039.png" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320004055.png" alt=""></p><hr><h3 id="1-5-Role-of-SE-Blocks">1.5 Role of SE Blocks</h3><h4 id="a-Squeeze的作用">a. Squeeze的作用</h4><p>作者做了一个对照试验，去掉pooling层，将Fc层换成CNN层，结果如下↓</p><p>这一板块看不太懂，先跳过吧</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320203340.png" alt=""></p><h4 id="b-Excitation">b. Excitation</h4><p>作者从ImageNet验证集中均衡采样了4个类别，每个类别50张，查看他们在SE-ResNet每个stage的最后一个block的激活情况</p><p>作者得出了下面三个结论（SE_stageID_blockID）</p><blockquote><p>First，在SE-ResNet前面的层，激活是相似的，eg：SE_2_3。作者认为在浅层神经网络，不同类别间特征通道的重要性是共享的</p><blockquote><p>浅层的神经网络提取到的是<strong>普适性</strong>的颜色、纹理、形状等特征，并没有特化。融合特征起到分类作用是深层做得事</p></blockquote><p>Second，层数越深，通道的激活就越类别特化，这是因为不同类别对于特征的价值有偏好。也就是说不同的类别激活的是不同的区域。网络越深，提取到的语义信息越丰满，激活所呈现出的层次感差别感就越明显。SE_4_6和SE_5_1</p><p>第三，SE_5_2中，SE退化为恒等映射；SE_5_3中，类别间差异很小了。这说明，在深层网络，SE起到的作用范围变小了，这是因为，在深层网络，特征已经高度可分，再使用SE模块就没有必要了，可以去掉。</p><blockquote><p>这也再次证明了1.2中结论，over！</p></blockquote></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220320204346.png" alt=""></p><hr><hr><h1>2.ECAnet论文</h1><h3 id="0-引子">(0) 引子</h3><p>ECAnet其实是SEnet的升级变种，ECAnet的核心思想有两个：</p><p><strong>一是在获取注意力的过程中不对全局平均池化后的1x1xC的长向量进行降维处理</strong></p><blockquote><p>降维会丢失信息，降低模型性能，有实验证明</p></blockquote><p><strong>二是使用1x1xK的自适应卷积核进行局部跨通道信息交融来提高计算效率</strong></p><blockquote><p>因为引入通道注意力机制本身就会引入额外的计算量，作者的关注点在于能否找到一种经济高效的方式来计算通道注意力</p></blockquote><h3 id="1-综述">(1) 综述</h3><p>通道注意力在提升模型性能方面潜力巨大，SEnet就是其中具有代表性的一种结构，其通过学习卷积块的通道注意，为多个深度CNN带来了清晰可见的性能增益。在这之后，有不少改进SEnet的研究，比如捕获更加复杂的通道依赖或者结合空间注意力。尽管这些方法增加了模型预测的正确率，但是也带来更高的计算代价和负担。</p><p>因此，作者提出了一个问题：能否以更加有效的方式学习高效率的通道注意力机制</p><blockquote><p>注意：这里有两个有效，一是学习方式高效，二是通道注意力机制高效</p></blockquote><p>本篇论文工作总结如下：</p><blockquote><p>1.避免降维+合适的跨通道信息交融对于有效学习和产生高效通道注意力很重要</p><p>2.尝试为深度CNN设计一种权重更轻/少的(叫做ECA的)模块，在增加极少运算量的同时，明显增益模型性能</p><p>3.在ImageNet-1K以及MS COCO数据集上的结果表明ECAnet能比当年的SOTA模型的复杂度更低，但是性能却相当有竞争力。(也就是说，我计算量更低，但性能不必SOTA差，牛逼就完事儿了)</p></blockquote><h3 id="2-核心逻辑论证">(2) 核心逻辑论证</h3><p>论文对<strong>引子</strong>中提到的两个点进行了实验论证</p><h4 id="1-避免降低特征维度">1.避免降低特征维度</h4><p>SE-Var1~SE-Var3是SEnet的三个变种，本文实验中，作者在全局平均池化后没有对这三个变种均进行降维，但其Top1和Top5的正确率反而提高了，实验证明，<strong>避免降维是能够提高模型精度的</strong></p><blockquote><ul><li>SE-Var1没引入额外参数，也比Vanilla好，证明通道注意力是有用的</li><li>SE-Var2每个通道独立学习权重，效果比SE好，作者认为原因可能是通道和权重应当是直接相关联的，而不是像SEnet先降维再重新映射回原来的输入尺寸。</li><li>SE-Var2只用了一层FC层，还是证明了降维不行</li></ul></blockquote><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220317231230.png"/><h4 id="2-局部信息跨通道交融">2.局部信息跨通道交融</h4><p>作者提出了一种ECA模块，融合了“能够捕捉跨通道信息”和“解决组卷积的不同组之间丢失联系”的优点</p><p>使用1x1xK的卷积核对全局平均池化后的1x1xC的长向量就行卷积操作</p><blockquote><p>对于边缘上的1x1xC的长向量的值，采用K/2的padding</p><p>卷积操作使用这一个卷积核，类似于权值共享的性质，减少了参数的数量，</p></blockquote><p>也就是下图中这个带状举矩阵，进行的就是上面所说的卷积操作</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220317235506.png"/><p>现在来看文章开头的图，是不是更清晰了，对于ECAnet的整个流程，有了更为清晰的了解</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318000133.png"/><h4 id="3-局部跨通道信息交融的范围-也就是1x1xK中的K的取值">3.局部跨通道信息交融的范围(也就是1x1xK中的K的取值)</h4><p>如果采取人工实验交叉验证实验的方式来确定每一个网络的最优K，会消耗很多计算机算力</p><p>作者设计了一个公式，使用非线性的映射来求自适应的K值</p><blockquote><p>下图中gamma和b的值分别是2和1，这是作者实验出来的</p></blockquote><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318000536.png"/><p>来看这个图，使用了自适应的网络确实比人工派遣K值要好得多</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318000737.png"/><h3 id="三-实验结果">(三) 实验结果</h3><p>没啥好说的，直接上图</p><p>基于几个经典的Backbone</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318000859.png"/><p>看下来，InceptionV3是真的强</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220318000954.png"/>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECA_MobilenetV2代码详解</title>
      <link href="/2022/03/19/f_eca_mobilenetv2%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/03/19/f_eca_mobilenetv2%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="ECA-MobilenetV2">ECA_MobilenetV2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> .eca_module <span class="keyword">import</span> eca_layer</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;ECA_MobileNetV2&#x27;</span>, <span class="string">&#x27;eca_mobilenet_v2&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model_urls = &#123;</span><br><span class="line">    <span class="string">&#x27;mobilenet_v2&#x27;</span>: <span class="string">&#x27;https://download.pytorch.org/models/mobilenet_v2-b0353104.pth&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积-&gt;BN-&gt;ReLU6算是MBV2的标配了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvBNReLU</span>(<span class="params">nn.Sequential</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_planes, out_planes, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, groups=<span class="number">1</span></span>):</span></span><br><span class="line">        padding = (kernel_size - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="built_in">super</span>(ConvBNReLU, self).__init__(</span><br><span class="line">            nn.Conv2d(in_planes, out_planes, kernel_size, stride, padding, groups=groups, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(out_planes),</span><br><span class="line">            nn.ReLU6(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义倒残差结构类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inp, oup, stride, expand_ratio, k_size</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(InvertedResidual, self).__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 隐藏层的维度，输入通道x扩展因子</span></span><br><span class="line">        hidden_dim = <span class="built_in">int</span>(<span class="built_in">round</span>(inp * expand_ratio))</span><br><span class="line">        <span class="comment"># 当且仅当stride=1且inp=oup的时候才使用恒等映射</span></span><br><span class="line">        self.use_res_connect = self.stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义层列表</span></span><br><span class="line">        layers = []</span><br><span class="line">        <span class="comment"># MobieleNetV2中第一个bottleneck是没有进行膨胀处理的</span></span><br><span class="line">        <span class="keyword">if</span> expand_ratio != <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># pw</span></span><br><span class="line">            layers.append(ConvBNReLU(inp, hidden_dim, kernel_size=<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># extend其实和append一个意思，只是可以一次多加几个层而已</span></span><br><span class="line">        layers.extend([</span><br><span class="line">            <span class="comment"># 3x3 dw conv</span></span><br><span class="line">            <span class="comment"># groups=1就是常规卷积，而当groups=hidden_dim的时候就是DW卷积，也就是一个通道对应一个卷积核</span></span><br><span class="line">            ConvBNReLU(hidden_dim, hidden_dim, stride=stride, groups=hidden_dim),</span><br><span class="line">            <span class="comment"># 1x1 pw-linear（linear通过conv来实现）</span></span><br><span class="line">            <span class="comment"># 线性函数，所以使用最原始的Conv2d</span></span><br><span class="line">            nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(oup),</span><br><span class="line">        ])</span><br><span class="line">        <span class="comment"># 倒残差模块尾巴后边接eca_layer</span></span><br><span class="line">        layers.append(eca_layer(oup, k_size))</span><br><span class="line">        <span class="comment"># 调用Sequential类，将layers以位置参数的形式传给conv(相当于把之前的一系列结构打包起名为conv)</span></span><br><span class="line">        self.conv = nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 判断是否使用捷径分支/恒等映射连接/ShortCut都是一个意思</span></span><br><span class="line">        <span class="keyword">if</span> self.use_res_connect:</span><br><span class="line">            <span class="keyword">return</span> x + self.conv(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.conv(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ECA_MobileNetV2</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># width_mult是宽度超参数，控制每一层卷积核的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes=<span class="number">1000</span>, width_mult=<span class="number">1.0</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ECA_MobileNetV2, self).__init__()</span><br><span class="line">        block = InvertedResidual</span><br><span class="line">        input_channel = <span class="number">32</span></span><br><span class="line">        last_channel = <span class="number">1280</span></span><br><span class="line">        inverted_residual_setting = [</span><br><span class="line">            <span class="comment"># t, c, n, s</span></span><br><span class="line">            <span class="comment"># t是膨胀率，c是卷积核个数，n是该bottleneck重复次数，s是首个模块的步长</span></span><br><span class="line">            [<span class="number">1</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">96</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">160</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">            [<span class="number">6</span>, <span class="number">320</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># building first layer</span></span><br><span class="line">        input_channel = <span class="built_in">int</span>(input_channel * width_mult)</span><br><span class="line">        self.last_channel = <span class="built_in">int</span>(last_channel * <span class="built_in">max</span>(<span class="number">1.0</span>, width_mult))</span><br><span class="line">        <span class="comment"># 这个其实是定义MBV2的第一个卷积层</span></span><br><span class="line">        features = [ConvBNReLU(<span class="number">3</span>, input_channel, stride=<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># building inverted residual blocks</span></span><br><span class="line">        <span class="keyword">for</span> t, c, n, s <span class="keyword">in</span> inverted_residual_setting:</span><br><span class="line">            output_channel = <span class="built_in">int</span>(c * width_mult)</span><br><span class="line">            <span class="comment"># n代表重复次数嘛，所以循环搭建倒残差结构</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> c &lt; <span class="number">96</span>:</span><br><span class="line">                    ksize = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ksize = <span class="number">3</span></span><br><span class="line">                <span class="comment"># 第一层，步长设置为s，不然设置为1</span></span><br><span class="line">                stride = s <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                features.append(block(input_channel, output_channel, stride, expand_ratio=t, k_size=ksize))</span><br><span class="line">                input_channel = output_channel</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># building last several layers</span></span><br><span class="line">        features.append(ConvBNReLU(input_channel, self.last_channel, kernel_size=<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 上面的层也叫做特征提取层，已经搭建完毕了</span></span><br><span class="line">        <span class="comment"># make it nn.Sequential</span></span><br><span class="line">        self.features = nn.Sequential(*features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># building classifier</span></span><br><span class="line">        <span class="comment"># 这里似乎没有使用平均池化下采样</span></span><br><span class="line">        <span class="comment"># self.avgpool = nn.AdaptiveAvgPool2d((1,1)) 给定输出矩阵的高和宽是1x1的，通道就是平均池化前的通道数</span></span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            <span class="comment"># 原论文用的是0.2，这里注意一下</span></span><br><span class="line">            nn.Dropout(<span class="number">0.25</span>),</span><br><span class="line">            nn.Linear(self.last_channel, num_classes),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># weight initialization</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="comment"># 是卷积层，就给个初始化</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>)</span><br><span class="line">                <span class="comment"># 存在偏置，偏置项就设为0</span></span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.zeros_(m.bias)</span><br><span class="line">            <span class="comment"># 如果子模块是BN层</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                <span class="comment"># 方差设置为1</span></span><br><span class="line">                nn.init.ones_(m.weight)</span><br><span class="line">                <span class="comment"># 均值设置为0</span></span><br><span class="line">                nn.init.zeros_(m.bias)</span><br><span class="line">            <span class="comment"># 如果子模块是全连接层</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                <span class="comment"># 均值为0，方差为0.01的正态分布函数</span></span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># 有偏置项，偏置项设置为0</span></span><br><span class="line">                    nn.init.zeros_(m.bias)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 特征提取</span></span><br><span class="line">        x = self.features(x)</span><br><span class="line">        <span class="comment"># 下面的操作和pytorch官方给的有出入，不知道为啥</span></span><br><span class="line">        x = x.mean(-<span class="number">1</span>).mean(-<span class="number">1</span>)</span><br><span class="line">        x = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eca_mobilenet_v2</span>(<span class="params">pretrained=<span class="literal">False</span>, progress=<span class="literal">True</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Constructs a ECA_MobileNetV2 architecture from</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">        progress (bool): If True, displays a progress bar of the download to stderr</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = ECA_MobileNetV2(**kwargs)</span><br><span class="line">    <span class="comment"># if pretrained:</span></span><br><span class="line">    <span class="comment">#     state_dict = load_state_dict_from_url(model_urls[&#x27;mobilenet_v2&#x27;],</span></span><br><span class="line">    <span class="comment">#                                           progress=progress)</span></span><br><span class="line">    <span class="comment">#     model.load_state_dict(state_dict)</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ECA-Modules">ECA_Modules</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn.parameter <span class="keyword">import</span> Parameter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eca_layer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Constructs a ECA module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        channel: Number of channels of the input feature map</span></span><br><span class="line"><span class="string">        k_size: Adaptive selection of kernel size</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 作者实验下来k等于3是合适的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, channel, k_size=<span class="number">3</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(eca_layer, self).__init__()</span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.conv = nn.Conv1d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=k_size, padding=(k_size - <span class="number">1</span>) // <span class="number">2</span>, bias=<span class="literal">False</span>) </span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># feature descriptor on the global spatial information</span></span><br><span class="line">        <span class="comment"># 全局平局池化</span></span><br><span class="line">        y = self.avg_pool(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Two different branches of ECA module</span></span><br><span class="line">        <span class="comment"># 局部跨通道信息交融，使用1x1xC的卷积核实现</span></span><br><span class="line">        y = self.conv(y.squeeze(-<span class="number">1</span>).transpose(-<span class="number">1</span>, -<span class="number">2</span>)).transpose(-<span class="number">1</span>, -<span class="number">2</span>).unsqueeze(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Multi-scale information fusion</span></span><br><span class="line">        <span class="comment"># sigmoid函数，将长向量的值压缩到0~1之间，起到权重关注的作用</span></span><br><span class="line">        y = self.sigmoid(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x * y.expand_as(x)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> cv </tag>
            
            <tag> ecanet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划习题集锦（二）</title>
      <link href="/2022/03/16/f_leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%BA%8C)/"/>
      <url>/2022/03/16/f_leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="1-完全平方数">1.完全平方数</h3><h5 id="题目">题目</h5><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220315214949.png" alt=""></p><h5 id="思路">思路</h5><p>咋一看其实没有思路，不妨沿着题意出发，设dp[i]表示i的完全平方数的最少数量</p><p>dp[0]=0;dp[1]=1;dp[2]=2,dp[3]=3;dp[4]=1;</p><p>因此对于每一个1，可以从j=1开始，且j*j&lt;=i来遍历</p><p>状态转移方程为</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220315215256.png" alt=""></p><p>老实说，真的不知道这个咋来，嘿嘿，</p><h5 id="Code">Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = minn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-丑数2">2.丑数2</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316184546.png" alt=""></p><h5 id="思路-2">思路</h5><p>老实说，一开始我没看懂这个题目，嚓。</p><p>题目的意思是找到只能整除2、3or5的数</p><p>最小的丑数是1，则1x2，1x3，1x5是丑数；1x2x2，1x2x3，1x2x5也是丑数…</p><p>所以用3指针来解决这个问题，<code>dp[i]</code>中存放的值表示第i个丑数</p><p>话不多说直接看Code，非常秒的解法，再次印证了自己是个fw的事实</p><h5 id="Code-2">Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k2=<span class="number">0</span>,k3=<span class="number">0</span>,k5=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//丑数递增存储</span></span><br><span class="line">            dp[i]=<span class="built_in">min</span>(<span class="number">2</span>*dp[k2],<span class="built_in">min</span>(<span class="number">3</span>*dp[k3],<span class="number">5</span>*dp[k5]));</span><br><span class="line">            <span class="comment">//加倍之后依然存在大小关系</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">2</span>*dp[k2]) k2++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">3</span>*dp[k3]) k3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="number">5</span>*dp[k5]) k5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> c++ </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention/Self-Attention/Transformer</title>
      <link href="/2022/03/16/f_attention-selfatten-tran/"/>
      <url>/2022/03/16/f_attention-selfatten-tran/</url>
      
        <content type="html"><![CDATA[<h1>引子</h1><h3 id="一些废话">一些废话</h3><p>Attention真的好难，要说总结相关知识点，还真不知道从何写起，感觉太大又太广。写出来可能没啥质量，但不写的话，以后复习又得翻阅大量资料，效率太低。所以，还是打算好好准备下，写下这篇文章</p><h3 id="参考文献">参考文献</h3><p>为了写出这篇帖子，阅读了大量的文章，也算是取各家之长了，但是总还是感觉少了点什么，有时间还是得阅读下原始论文</p><h1>Attention/Self-Attention/Transformers</h1><h2 id="1-Attention">1.Attention</h2><h3 id="a-What-is-Attention？">a. What is Attention？</h3><p>Attention机制是一种通用的思想，不会局限于某一框架。</p><p>从宏观来言，Attention起到的是一种解决遗忘，关注/突出重点的作用</p><p>从概念上来理解，从大量信息中有选择地筛选出少量重要信息并聚焦到这些重要信息上，忽略大多不重要的信息</p><p>具体到某一个项目来说…</p><p>从种类来看，<strong>Spatial Attention 空间注意力</strong>和<strong>Temporal Attention 时间注意力</strong></p><p>从实际应用来看，<strong>Soft Attention</strong>和<strong>Hard Attention</strong></p><blockquote><p><strong>Soft Attention是所有的数据都会注意，都会计算出相应的注意力权值，不会设置筛选条件</strong></p><p><strong>Hard Attention会在生成注意力权重后筛选掉一部分不符合条件的注意力，让它的注意力权值为0，即可以理解为不再注意这些不符合条件的部分</strong></p></blockquote><h3 id="b-Why-Attention">b. Why Attention</h3><h4 id="1-作用">1.作用</h4><ul><li>Attention机制解决了Seq2seq序列模型中Encoder最后一层隐藏层输出的信息瓶颈问题，解决了RNN的长程遗忘问题，对输入句子的部分词施加注意力从而使得预测更加准确，更加确信。</li></ul><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316224017.png" width=500/><ul><li><p>有助于缓解梯度消失问题，因为Decoder的每一时间步都和所有Encoder的隐状态相连了，相当于某种捷径，减少了“中间商赚差价”</p><blockquote><p>这么理解，梯度消失还是有，缓解的是梯度消失对预测造成的影响，因为施加了attention，原来网络所存在的梯度消失问题带来的影响就不存在了</p></blockquote></li><li><p>有助于增加NMT的可解释性，解释为什么时刻t翻译输出了某个词，可以通过查看Attentioin distribution来解释</p><blockquote><p>Attentioin distribution也就是每个Encoder隐藏层的权重</p></blockquote></li></ul><h4 id="2-朴素RNN存在的问题">2.朴素RNN存在的问题</h4><p>Encoder-Decoder模型是注意力不集中的分心模型。</p><p>下图中y是Decoder预测输出，而f是decoder的非线性变换函数。</p><p>语义编码C是由输入句子X的每个单词经过Encoder 编码产生，而每一个y所使用的语义编码C都是一样，<strong>句子X中任意单词对生成某个目标单词y来说影响力都是相同的，没有任何区别</strong></p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316231701.png"/><p>引入Attention之后，<strong>原先都是相同的中间语义表示C会替换成根据当前生成单词而不断变化的Ci</strong>，<strong>理解AM模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的Ci</strong></p><h3 id="C-Details-in-Attention">C. Details in Attention</h3><h4 id="1-Attention计算方式–原始论文">1.Attention计算方式–原始论文</h4><p>step1：Deconder的输入隐层状态s和Encoder的每一个隐层状态h做concat，接着左乘权重矩阵，经过tanh函数后，与矩阵v求点积得到attention scores</p><p>step2：attention scores再经过softmax函数，映射为概率，也就是Attentioin distribution</p><p>step3：Attentioin distribution与Encoder隐层状态求加权和，得到该时刻Deconder的上下文向量c</p><p>step4：上下午向量v再和Encoder隐层状态s做concat作为预测输入，求出该时刻的预测值</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316233608.png"/><h4 id="2-更流行的一种方法，同Transformer">2.更流行的一种方法，同Transformer</h4><p>思路同上面这种方法，只是求相似度的计算形式不同罢了，一个意思。</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316234204.png"/> <img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220316235017.png"/>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划习题集锦（一）</title>
      <link href="/2022/03/14/f_leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%80)/"/>
      <url>/2022/03/14/f_leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1>知识点</h1><h1>简单题</h1><h3 id="1-爬楼梯">1.爬楼梯</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220227193631.png" alt=""></p><p>思路：不妨用sum[i]表示i个阶梯可以走的方法的总数，则sum[0]=0，sum[1]=1，sum[2]=2。故可以分解操作。</p><blockquote><p>若n=3，第一次走1个台阶，余下还剩sum[2]，第一次走2个台阶，余下还剩sum[1]。sum[3]=sum[2]+sum[1]</p><p>若n=4，第一次走1个台阶，余下还剩sum[3]，第一次走2个台阶，余下还剩sum[2]。sum[4]=sum[3]+sum[2]</p><p>若n=5，第一次走1个台阶，余下还剩sum[4]，第一次走2个台阶，余下还剩sum[3]。sum[4]=sum[3]+sum[2]</p><p>…</p><p>若n=n，第一次走1个台阶，余下还剩sum[n-1]，第一次走2个台阶，余下还剩sum[n-2]。sum[n]=sum[n-1]+sum[n-2]</p></blockquote><p>代码如下👇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## 纯c++</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clinbstair</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *sum=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;sum[<span class="number">1</span>]=<span class="number">1</span>;sum[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+sum[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## LeetCode</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> *sum=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>]=<span class="number">0</span>;sum[<span class="number">1</span>]=<span class="number">1</span>;sum[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+sum[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-杨辉三角">2.杨辉三角</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220227212708.png" alt=""></p><p>思路：没啥思路，一看就知道通项公式，就是写不出代码，哭了</p><blockquote><p>重新学些了下C++的二维vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处的m是初始化a的大小，m=array.size()，而不是初始值；</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(m);</span><br><span class="line"><span class="comment">//初始化一个m*n的二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    a[i].<span class="built_in">resize</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值，like二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][j] = (<span class="number">3</span>*i+j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">## LeetCode题解</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="comment">//此处的m是初始化a的大小，m=array.size()，而不是初始值；</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);<span class="comment">//初始化一个i*(i+1)的二维数组</span></span><br><span class="line">            a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">                a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="function">CPP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yhsj</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//初始化一个m*n的二维数组</span></span><br><span class="line">        a[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">        a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印出来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-杨辉三角2">3.杨辉三角2</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220227213831.png" alt=""></p><p>思路：这个题代码基本和上一题一样，注意rowIndex=3的时候，其实是求得第4行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## LeetCode题解</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处的m是初始化a的大小，m=array.size()，而不是初始值；</span></span><br><span class="line">        <span class="comment">//数组下标从0开始，求3其实要4，所有是rowIndex+1</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(rowIndex+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].<span class="built_in">resize</span>(i+<span class="number">1</span>);<span class="comment">//初始化一个i*(i+1)的二维数组</span></span><br><span class="line">            a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">                a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二维数组指定第一个方框内数，就能打印一行了，牛批</span></span><br><span class="line">        <span class="keyword">return</span> a[rowIndex];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-买卖股票的最佳时机">4.买卖股票的最佳时机</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220228134932.png" alt=""></p><p>思路：直接暴力做，但是超时了，尴尬</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">### 下面是自己的写的暴力破解</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(midnum&lt;=prices[j]-prices[i])</span><br><span class="line">            midnum=prices[j]-prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxnum= <span class="built_in">max</span>(maxnum,midnum);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxnum&lt;&lt;endl;</span><br></pre></td></tr></table></figure></blockquote><p>令dp[i]表示第i天的的最大值，则dp[i]显然等于dp[i-1]和prices[i]-minum之间的较大值</p><blockquote><p>状态转移方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i]= max(dp[i-1],a[i]-minnum)</span><br><span class="line">minnum= min(minnum,a[i]);</span><br></pre></td></tr></table></figure></blockquote><p>代码如下↓</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边界条件</span></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minnum=a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//求出dp的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    dp[i]= <span class="built_in">max</span>(dp[i<span class="number">-1</span>],a[i]-minnum);</span><br><span class="line">    minnum= <span class="built_in">min</span>(minnum,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环找到最大的值</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;dp[i])</span><br><span class="line">            ans=dp[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-比特位计数">5.比特位计数</h3><p><img src="C:%5CUsers%5CJlthz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220301212011302.png" alt="image-20220301212011302"></p><p>别人的思路：</p><blockquote><p>1.奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1</p><blockquote><p>举例：</p><p>0 = 0       1 = 1</p><p>2 = 10      3 = 11</p></blockquote><p>2.偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><blockquote><p>举例</p><p>2 = 10       4 = 100       8 = 1000</p><p>3 = 11       6 = 110       12 = 1100</p></blockquote></blockquote><p>答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = result[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result[i] = result[i/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而自己的答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cul_one</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i_1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            i_1++;</span><br><span class="line">        n=n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> *nums = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        nums[i]= <span class="built_in">cul_one</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;nums[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-判断子序列">6.判断子序列</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220301214729.png" alt=""></p><p>本质就是贪心策略，使用双指针。首先i指向s，j指向t。若s[i]和t[j]相等，则i和j都自增1，若不等则j自增1。最后仅仅需判断i的值和s的长度，相等则返回true，不等则返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-使用最小花费爬楼梯">7.使用最小花费爬楼梯</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220302194043.png" alt=""></p><p>思路：坚持了几分钟还是放弃了，看了下答案的思路，自己还是太菜了</p><p>不妨设走完i阶楼梯所用的最小花费为minCost[i],则走完第i阶有两个选择</p><blockquote><p>1.先花掉minCost[i-1]，走完第i-1个阶梯，然后再走一步花费cost[i]</p><p>2.先花掉minCost[i-2]，走完第i-2个阶梯，然后再走两步花费cost[i-1]</p></blockquote><p>所以，就有了 minCost[i]=min(minCost[i-1]+cost[i]，minCost[i-2]+cost[i-1])</p><p>台阶的数组从<code>0</code>开始计数。可以用<code>-1</code>代表地面，并设<code>cost[-1] = 0</code></p><p>minCost[0] = min(cost[-1], cost[0]) = min(0, cost[0]) = 0</p><p>minCost[1] = min(cost[0], cost[1])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = cost.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minCost</span><span class="params">(size)</span></span>;</span><br><span class="line">    minCost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    minCost[<span class="number">1</span>] = <span class="built_in">min</span>(cost[<span class="number">0</span>], cost[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">        minCost[i] = <span class="built_in">min</span>(minCost[i - <span class="number">1</span>] + cost[i], minCost[i - <span class="number">2</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost[size - <span class="number">1</span>];<span class="comment">//数组下标从0开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-获取生成数组中的最大值">8.获取生成数组中的最大值</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220303201025.png" alt=""></p><p>非动态规划做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaximumGenerated</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *nums=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    nums[<span class="number">0</span>]=<span class="number">0</span>;nums[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> nums[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        nums[<span class="number">2</span>*i]=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=n)&#123;</span><br><span class="line">            nums[<span class="number">2</span>*i+<span class="number">1</span>]=nums[i]+nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;nums[i])&#123;</span><br><span class="line">            ans=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划做法(用vector向量来做很不错)</p><blockquote><p>i为奇数,nums[i]=nums[i/2]+nums[i/2+1];<br>i为偶数,nums[i]=nums[i/2];<br>可见两者都有nums[i/2]，可合并。</p><p>nums[i]=nums[i/2]+(i%2)*nums[i/2+1];</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGenerated</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i/<span class="number">2</span>] + (i%<span class="number">2</span>)*ans[i/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-传递信息">9.传递信息</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220303215011.png" alt=""></p><p>动态规划的基本思路其实已经有了，就是难以通过代码实现出来，就很尴尬。</p><p>定义动态规划的状态 <code>dp[i][j]</code>为经过 i轮传递到编号 j的玩家的方案数</p><p>那么<code>dp[0][j]</code>=1(当j=0时，就是自己给自己)，<code>dp[0][j]</code>=0(当j不等于0的时候)</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220303215428.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">dp</span>(k+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; edge :relation )&#123;</span><br><span class="line">            <span class="keyword">int</span> s1=edge[<span class="number">0</span>],s2=edge[<span class="number">1</span>];</span><br><span class="line">            dp[i+<span class="number">1</span>][s2]+=dp[i][s1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-三步走问题">10.三步走问题</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220305205931.png" alt=""></p><p>思路：状态转移方程其实就是<code>dp[i]=(dp[i-1]+dp[i-2]+dp[i-3])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始版本 结果就是堆栈爆炸嚓</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]+=(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]+dp[i<span class="number">-3</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改之后的版本，堆栈不炸了，这个方法很妙哈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> dp[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>&#125;;</span><br><span class="line">     <span class="keyword">if</span>(n&lt;<span class="number">5</span>) <span class="keyword">return</span> dp[n<span class="number">-1</span>]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">2</span>]=dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">3</span>]=(dp[<span class="number">0</span>]+dp[<span class="number">1</span>]+dp[<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-按摩师问题">11.按摩师问题</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306211344.png" alt=""></p><p>到底还是自己题目做少了，遇到新的题目就没有啥思路了</p><p>这里直接看官方的解答，已经很妙了</p><p>主要还是滚动数组的思想</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306211427.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tdp0 = <span class="built_in">max</span>(dp0, dp1); <span class="comment">// 计算 dp[i][0]</span></span><br><span class="line">            <span class="keyword">int</span> tdp1 = dp0 + nums[i]; <span class="comment">// 计算 dp[i][1]</span></span><br><span class="line"></span><br><span class="line">            dp0 = tdp0; <span class="comment">// 用 dp[i][0] 更新 dp_0</span></span><br><span class="line">            dp1 = tdp1; <span class="comment">// 用 dp[i][1] 更新 dp_1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-不同的二叉搜索树">12 不同的二叉搜索树</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308212700.png" alt=""></p><p>这道题和复旦大学2019年的机试题很像，也更难一点，但对于理解动态规划很有意思</p><p>来看看官方的解答</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308212814.png" alt=""></p><p>Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>) <span class="keyword">return</span> n; </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;dp[<span class="number">0</span>]=<span class="number">1</span>;dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">//一路增长过去</span></span><br><span class="line">                dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="13-目标和">13 目标和</h3><p>再次感觉，废物永远就是废物，这道题目拿到手完全没有思路，就很痛苦，淦！</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220309200209.png" alt=""></p><h4 id="解答1-回溯法">解答1 回溯法</h4><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220309200515.png" alt=""></p><p>Code如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// index标及下标是否超过nums数组范围，sum表示求和</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backstrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">backstrack</span>(nums,target,index+<span class="number">1</span>,sum+nums[index]);</span><br><span class="line">            <span class="built_in">backstrack</span>(nums,target,index+<span class="number">1</span>,sum-nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backstrack</span>(nums,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220309200603.png" alt=""></p><h4 id="解法2-完全看不懂">解法2 完全看不懂</h4><p>废物就是废物 淦</p><p>贴个链接，以后回来看</p><p><a href="https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/</a></p><h3 id="14-打家劫舍2">14 打家劫舍2</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310191214.png" alt=""></p><p>这道题其实和11题的按摩师是一个体型，不过这里变成了环</p><p>因此本题可以分区间来做，//Case1 范围0~n-2；//Case2 范围1~n-1</p><p>代码如下👇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>||size==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case1 范围0~n-2</span></span><br><span class="line">        <span class="keyword">int</span> dp0=<span class="number">0</span>,dp1=<span class="number">0</span>;</span><br><span class="line">        dp1=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;size<span class="number">-1</span>; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tdp0 = <span class="built_in">max</span>(dp0, dp1); <span class="comment">// 计算 dp[i][0]</span></span><br><span class="line">            <span class="keyword">int</span> tdp1 = dp0 + nums[i]; <span class="comment">// 计算 dp[i][1]</span></span><br><span class="line"></span><br><span class="line">            dp0 = tdp0; <span class="comment">// 用 dp[i][0] 更新 dp_0</span></span><br><span class="line">            dp1 = tdp1; <span class="comment">// 用 dp[i][1] 更新 dp_1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1=<span class="built_in">max</span>(dp0,dp1);</span><br><span class="line">        <span class="comment">//Case2 范围1~n-1</span></span><br><span class="line">        dp0=<span class="number">0</span>,dp1=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tdp0 = <span class="built_in">max</span>(dp0, dp1); <span class="comment">// 计算 dp[i][0]</span></span><br><span class="line">            <span class="keyword">int</span> tdp1 = dp0 + nums[i]; <span class="comment">// 计算 dp[i][1]</span></span><br><span class="line"></span><br><span class="line">            dp0 = tdp0; <span class="comment">// 用 dp[i][0] 更新 dp_0</span></span><br><span class="line">            dp1 = tdp1; <span class="comment">// 用 dp[i][1] 更新 dp_1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans2=<span class="built_in">max</span>(dp0,dp1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans1,ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15-买股票的时机2">15 买股票的时机2</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310204043.png" alt=""></p><p>根据题目意思，当天买入可以当天卖出</p><h5 id="思路1">思路1</h5><p>因此可以简化题目的难度，只要第二天的比第一天的大，咱就卖出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>||size==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">2</span>) <span class="keyword">return</span> prices[<span class="number">1</span>]&gt;prices[<span class="number">0</span>]?(prices[<span class="number">1</span>]-prices[<span class="number">0</span>]):<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">                ans+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思路2-DP">思路2 DP</h5><p>状态转移方程还是难写，感觉每做一次都有新的思路，完全是不重样的DP，太难了</p><p>这里的思路隐含了一个值value，用来衡量最后的总价值，买入股票则value-price[i]，卖出股票则value+price[i]</p><p>所以，最后当手上没有股票的时候，必然是赢嘛了，因为，不赚钱，你不会买呀，至少也是赚0</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310204237.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再优化一下</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310204641.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDp0 = <span class="built_in">max</span>(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newDp1 = <span class="built_in">max</span>(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="16-动态规划">16.动态规划</h3><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220312213417.png" alt=""></p><h5 id="思路">思路</h5><p>其实在纸上推一推就知道了，空想是不会出结果的</p><h5 id="Code">Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//可以在纸上推一推，假设obstacleGrid[i][3]=1</span></span><br><span class="line">        <span class="comment">//则obstacleGrid[i][0、1、2]都等于1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="17-三角形最小路径和">17.三角形最小路径和</h3><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314151744.png"/><h5 id="思路-2">思路</h5><p>就是算法笔记上的塔问题，原题是求最大值，这里是求最小值</p><p>从底层向上求dp，最上层的点就是最小值</p><h5 id="Code-2">Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">//初始化dp数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) dp[j]=triangle[m<span class="number">-1</span>][j];</span><br><span class="line">        <span class="comment">//循环求解dp数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j+<span class="number">1</span>])+triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>贴一个结果，嘻嘻👇</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314152000.png"/><h3 id="18-最大的正方形">18.最大的正方形</h3><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314164622.png"/><h5 id="思路-3">思路</h5><p>咋一看其实是没思路的，完全处于懵逼状态，有点类似算法笔记中的‘1’块问题，如果套用‘1’块问题来解的话时间复杂度也太高了</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314165335.png"/><h5 id="Code-3">Code</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维vector数组可以用这个新的写法了，之前的太麻烦了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">       <span class="comment">//计算dp</span></span><br><span class="line">       <span class="keyword">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[i][j]=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   maxnum=<span class="built_in">max</span>(maxnum,dp[i][j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxnum*maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> c++ </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs224n课程笔记</title>
      <link href="/2022/03/14/cs224n%E8%AF%BE%E7%A8%8B%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/03/14/cs224n%E8%AF%BE%E7%A8%8B%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>写在前面</h1><p>CS224是一个很大且相对基础的讲解NLP的课程，因此不是所有内容对于复试来说都是重点，所以这篇文章会选择性的记录一些有利于复试，有利于项目的知识点</p><p>个人没有太多时间来从头到尾看课程视频，更读的是阅读别人的二手知识+多面化的搜查，因此也会补充一些自己觉得很棒的知识点，用来强化知识点，强化学习。</p><p>话不多说，Let’s GO!</p><h1>CS224N课程</h1><h2 id="1-基础性的概念记录-更新ing">1.基础性的概念记录(更新ing)</h2><p>1.Word embedding 是一个将词向量化的概念，word2vec是谷歌提出一种word embedding 的工具或者算法集合</p><blockquote><p>再细讲一下就是说，Word embedding是一种概念性的宏观的知识，而word2vec是实现这种概念的一种具体的方法，有点像类和实例的关系。</p></blockquote><p>2.word2vec的两类模型</p><blockquote><p>Skip-grams模型：给出一个词，预测其上下文</p><p>CBOW模型：给一个词的上下文，预测这个词</p></blockquote><p>3.Word2vec完全理解</p><blockquote><h4 id="a-引子">a.引子</h4><p>举个例子，我们输入单词the，想要预测单词quick</p><p>则输入是the的one-hot编码，输出是quick的one-hot编码</p><p>假设词典里有10,000个不同的词，则one-hot编码长度为10,000</p><p>假设只有一个隐藏层的全连接网络，则隐藏层对应权重构成两个权重矩阵，如下图👇</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/skip_gram_net_arch2.jpg" width=550/><p><strong>隐层和输入层连接的矩阵为V，其每一行表示词作为中心词时的词向量，输入行向量乘以V正好得到输入词的词向量</strong></p><blockquote><p>现在再来看王佬的视频，是不是有新的感悟</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220313234720.png" width=500/></blockquote><p><strong>隐层和输出层连接的权重矩阵为U，其每一列表示输出层的词的临近词词向量</strong></p><h4 id="b-总结">b.总结</h4><p>什么是词向量？也就是参数矩阵V中的行，一个单词的词向量就对应参数矩阵V的中的一个行。也就是说，参数矩阵/词向量是需要通过学习才能得到的。不妨再剥离出来，词向量就是使用低维向量来表示词的语义信息的向量，注意这里的低维是相对于高维且稀疏的one-hot向量而言。</p></blockquote><p>4.命名实体识别（Named Entity Recognition, NER）</p><blockquote><p>也就是把一个句子中的地点LOC、机构ORG和人名PER识别出来</p></blockquote><p>5.WHY预训练词向量</p><blockquote><p>如果有可用的预训练词向量，则最好使用预训练词向量。因为预训练的词向量通常在很大规模的数据集上进行过训练，词向量的质量还不错</p><p>而某个具体的NLP任务的样本数可能不太多，导致训练得到的词向量还没人家预训练的好。所以，如果实际任务的数据量较小，则用预训练的词向量；否则，可以尝试一下根据实际任务fine tune词向量</p></blockquote><p>5.BP算法</p><blockquote><p>不断使用链式法则对BP算法求导，然后反向传播。在反向传播的过程中，可以利用上游计算好的梯度，增量式的更新下游的梯度，[downstream gradient] = [upstream gradient] × [local gradient]</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/p20.png" width=500/></blockquote><p>6.Dependency Parsing依存分析</p><blockquote><p>指对句子进行语法分析并画出句子成分的依赖关系。主语、谓语、宾语啥子的。</p><p>WHY Dependency Parsing？</p><blockquote><p>a.了解句子结构能更好的理解句子的含义</p><p>b.人们在交流的时候，通过组合简单的句子成分来表达复杂的含义</p><p>c.需要知道句子中成分之间的依赖关系，以此来正确解读句子的含义</p></blockquote></blockquote><h2 id="2-Language-Models-and-RNNs">2.Language Models and RNNs</h2><p>1.n-gram</p><blockquote><p>在前-深度学习时代，人们使用n-gram方法来学习语言模型</p><p>对于一个句子the students opened their</p><ul><li>1-grams (unigrams): “the”, “students”, “opened”, “their”</li><li>2-grams (bigrams): “the students”, “students opened”, “opened their”</li><li>3-grams (trigrams): “the students opened”, “students opened their”</li><li>4-grams: “the students opened their”</li></ul><p><strong>n-gram方法有一个前提假设，即假设每个词出现的概率只和前n-1个词有关，通过前n-1个词语来预测第n个词</strong></p><blockquote><p>n-gram是存在一些问题的，例如我们统计训练集语料库中发现，分母students opened their出现1000次，其后接books即students opened their books出现了400次，所以P(books|students opened their)=400/1000=0.4，类似的，可以算出下一个词为exams的概率是0.1。所以4-gram方法认为下一个词是books的概率更大</p><p>但是，当原始输入句子是as the proctor started the clock, the students opened their的时候，显然，后边结果是books的可能性更大，这也是n-gram存在的问题</p></blockquote><p><strong>这里总结一下n-gram的不足</strong></p><blockquote><p>a.考虑的状态有限。n-gram只能看到前n-1个词，无法建模长距离依赖关系</p><p>b.存储问题，需要存储所有n-gram的频率，如果n越大，这种n-gram的组合越多，所以存储空间呈幂次上升</p><p>c.依赖于语料库，比如生物学中的顶尖优势(用w表示)，显然w在408课程组成的语料库中是稀有的，甚至没有的，但不能草率的认为w这个词不存在</p></blockquote></blockquote><p>2.RNN</p><blockquote><p><strong>RNN结构如下，每一时刻的输入包含两部分，即当前时刻的输入，和上一时刻隐状态的变换</strong></p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314100617.png" width=600/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314100216.png" width=500/><p><strong>RNN的优势和劣势</strong></p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314100929.png"/><p><strong>RNN理论上能建立长期的依赖关系，但是由于梯度消失和梯度爆炸的问题，学习到的依旧是短期的依赖关系。</strong></p><p><strong>核心问题：RNN在不同的时间步使用共享参数w，导致t+n时刻损失值对于t时刻参数的偏导数存在w的指数形式，当n很大的时候，如果w小于1，就梯度消失；如果w大于1，就梯度爆照</strong></p></blockquote><h2 id="3-Vanishing-Gradients-Fancy-RNNs">3.Vanishing Gradients, Fancy RNNs</h2><p>1.RNN梯度消失和爆炸</p><blockquote><h5 id="a-梯度消失">a.梯度消失</h5><p>核心问题就是RNN在不同时间步使用共享参数W，导致t+n时刻的损失对t时刻的参数的偏导数存在W的指数形式，一旦W很小或很大就会导致梯度消失或梯度爆炸的问题.</p><p>下图形象的显示了梯度消失的问题，即梯度不断反传，沿着箭头方向的梯度不断变小</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314103204.png" width=500/><p><strong>梯度消失带来的明显的问题就是：参数的更新受到临近词的影响更大，距离当前t时刻越远的参数更新就越少。久而久之，因为梯度消失，我们就不知道t时刻是真的对t+n时刻没影响还是因为梯度消失导致我们没学习到这种影响</strong></p><h5 id="b-梯度爆炸">b.梯度爆炸</h5><p>导致参数更新的一瞬间更新非常大，导致网络振荡</p><blockquote><p>梯度爆炸一个比较好的解决方法是梯度裁剪，即如果发现梯度的范数大于某个阈值，则以一定的比例缩小梯度的范数，但不改变其方向</p></blockquote><h5 id="c-总结">c.总结</h5><p>总的来说，梯度爆炸相对好解决，但梯度消失就没那么简单了。在RNN中，每个时刻t，都改写了前一个时刻的隐状态，而由于梯度消失问题，长距离以前的状态对当前时刻的影响又很小，所以导致无法建模长距离依赖关系</p></blockquote><p>2.LSTM</p><blockquote><h5 id="a-模型与计算">a.模型与计算</h5><ul><li><p>从宏观上来说，LSTM的隐层神经元不仅包含隐状态h，还专门开辟了一个cell来保存过去的“记忆”c，LSTM希望用c来传递很久以前的信息，以达到长距离依赖的目的。所以LSTM隐层神经元的输入是上一时刻的隐状态h和记忆c，输出是当前时刻的隐状态h和希望传递给下一个时刻的记忆c。</p></li><li><p>在当前输入时刻t，LSTM设置了遗忘门f和输入们i，f和i都由上一时刻的隐层状态h和当前时刻的输入计算而得</p></li><li><p>输出门o控制哪些记忆需要输出到下一个隐层状态</p><p>看图就可以了，没啥好说的</p></li></ul><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314112752.png" width=500/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314112909.png" width=500/></center><h5 id="b-总结-2">b.总结</h5><p>LSTM有3个门，遗忘门，输入门和输出门</p><p>朴素RNN把之前时间步的信息都一股脑存储在隐状态，隐状态就成了整个网络的瓶颈。LSTM的关键就是开辟了一个新的cell来存储记忆，相对于RNN多了一条获取以前信息的途径，因此能够<strong>缓解</strong>RNN梯度消失的问题</p><blockquote><p>虽然LSTM开辟新的cell来存储记忆，但这个记忆也会受到连续梯度相乘的影响，所以依然存在梯度消失或梯度爆炸的问题，但从实际效果来看，LSTM性能很不错，也很鲁棒</p></blockquote></blockquote><p>3.GRU</p><blockquote><h5 id="a-模型与计算-2">a.模型与计算</h5><p>GRU去掉了cell结构，且只设计了重置门和更新门</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314121125.png"/><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314120738.png" width=500/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314120717.png" width=500/></center><h5 id="b-结论">b.结论</h5><p>GRU和LSTM的性能差不多，但GRU参数更少，更简单，所以训练效率更高。但是，如果数据的依赖特别长且数据量很大的话，LSTM的效果可能会稍微好一点，毕竟参数量更多。所以默认推荐使用LSTM</p></blockquote><p>4.其它解决梯度消失问题的策略</p><blockquote><h5 id="a-双向RNN-BI-RNN">a.双向RNN(BI-RNN)</h5><ul><li><p>双向RNN，个从左往右，一个从右往左，两个RNN的参数是独立的。两层的参数输出concat一下给到隐藏层</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314121554.png" width=500/></li><li><p>对于双向RNN某个时刻t，需要知道t时刻前的信息（Forward RNN），又需要知道t时刻之后的信息（Backward RNN）。所以双向RNN无法用于学习语言模型，因为语言模型只知道时刻t之前的信息，下一时刻的词需要模型来预测。</p><blockquote><p>其实也就是解释了，为啥子Encoder要用双向，而Decoder要用单向</p></blockquote></li></ul><h5 id="b-多层RNN">b.多层RNN</h5><p>通常来说，深度越大，性能越好，如果梯度下降能训练好的话</p></blockquote><p>5.That’s ALL</p><blockquote><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314121938.png" width=600/><p>通常来说，RNN深度越大，性能越好。But越深的话梯度消失可能比较严重，串行计算而非并行化计算</p></blockquote><h2 id="4-Translation-Seq2Seq-Attention">4.Translation, Seq2Seq, Attention</h2><p>1.统计机器翻译SMT</p><blockquote><p>统计机器翻译非常复杂，有很多的子模块，需要很多的人工干预和特征工程。</p></blockquote><p>2.Seq2seq</p><blockquote><p>Seq2seq由Encoder和Decoder两部分组成。</p><h5 id="Encoder">Encoder</h5><p>Encoder RNN负责对源语言进行编码，学习源语言的隐含特征。Encoder RNN的最后一个神经元的隐状态作为Decoder RNN的初始隐状态。</p><h5 id="Decoder">Decoder</h5><p>Decoder RNN是一个条件语言模型，一方面它是一个语言模型，即用来生成目标语言的；另一方面，它的初始隐状态是基于Encoder RNN的输出，所以称Decoder RNN是条件语言模型。</p><p>Decoder RNN在预测的时候，需要把上一个神经元的输出作为下一个神经元的输入，不断的预测下一个词，直到预测输出了结束标志符<code>&lt;END&gt;</code>，预测结束。</p><h5 id="小结">小结</h5><p>Encoder RNN的输入是<strong>源语言</strong>的word embeding，Decoder RNN的输入是<strong>目标语言</strong>的word embeding</p><p>seq2seq的训练过程端到端的，也即EN作为整体来训练，也可以单独做，效果不一定有整体好</p></blockquote><p>3.BeamSearch</p><blockquote><h5 id="引子">引子</h5><p>Naive版本的Seq2seq的预测过程采取的是贪心策略，即在Decoder RNN的每一步都选择概率最大的词作为结果。But，每一步最优不一定是全局最优，因此翻译出来的对话不一定是最好的。若是采用穷举，那时间或者算力上来说都是不经济的。</p><h5 id="正片">正片</h5><p>Beam search搜索策略是贪心策略和穷举策略的一个折中方案，(假设每一步输出n个结果，n&gt;k)它在预测的每一个时间步都保留top-k个结果，将这k个预测输入到下一个时间步，得到k*n个结果。从这kn个结果中选出打分最高的k个，再输入下一个时间步…指导结束，最后回溯即可得到这个方法下的最优路径</p><blockquote><ul><li>a.注意，这里的<strong>打分</strong>是指从预测开始到结束，<strong>一整条路径打分</strong></li></ul><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314225212.png" width=500/><ul><li><p>b.注意<strong>beam search作为一种剪枝策略，并不能保证得到全局最优解</strong>，但它能以较大的概率得到全局最优解，同时相比于穷举搜索极大的提高了搜索效率。(k取1就是贪心策略，k取n就是穷举策略)</p></li><li><p>c.注意beam search过程中，不同路径预测输出结束标志符<code>&lt;END&gt;</code>的时间点可能不一样，提前结束的路径称为完全路径。暂时把这些完全路径放一边，其他路径接着beam search。<strong>beam search的停止条件有很多种，可以设置一个最大的搜索时间步数，也可以设置收集到的最多的完全路径数。</strong></p></li></ul></blockquote></blockquote><p>4.BLEU评价指标</p><blockquote><p>Bilingual Evaluation Understudy, BLEU</p><p>BLEU衡量机器翻译结果和人类的标注答案的n-gram的overlap，overlap越多，打分就越高</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314233749.png" align=left width=800/><p>也就是<code>分子=min（n-gram在所有参考答案句子中出现次数最大值，n-gram在结果c中出现的次数）</code></p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314234039.png" align=left width=800 /><p>论文中对于BLEU的讲解↓</p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220314234205.png" width=700/></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> cs224n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典CNN总结</title>
      <link href="/2022/03/11/f_%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/11/f_%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Inception系列">1.Inception系列</h2><h4 id="GoogLeNet-InceptionV1">GoogLeNet(InceptionV1)</h4><h5 id="（一）综述">（一）综述</h5><p>最直接最保险获得高质量模型做法就是增加模型的深度（层数）或者是其宽度（层核或者神经元数）</p><p>但是这里一般设计思路的情况下会出现如下的缺陷：</p><blockquote><p>1.参数太多，若训练数据集有限，容易过拟合</p><p>2.数据集标注难，成本高，不经济</p><p>3.网络越大计算复杂度越大，难以应用</p><p>4.网络越深，梯度越往后穿越容易消失，难以优化模型</p></blockquote><p>解决上述缺点的根本途径是用稀疏的连接结构来取代密集的连接结构。传统的网络都使用了随机稀疏连接来打破网络对称性和提高学习能力。但是现在的计算机软硬件对非统一/均匀的系数数据的计算效率不高。</p><p>因此有没有一种可能，能否在仍旧利用现有硬件进行密集矩阵运算的条件下，改进模型结构，哪怕只在卷积层水平改进从而能够利用额外的稀疏性呢？</p><h5 id="（二）Inception模块介绍">（二）Inception模块介绍</h5><p><strong>Inception的核心思想使用密集的模块去近似出最优的局部系数结构</strong></p><p><strong>Inception的作用：代替人工确定卷积层中的过滤器类型或者确定是否需要创建卷积层和池化层，即：不需要人为的决定使用哪个过滤器，是否需要池化层等，由网络自行决定这些参数，可以给网络添加所有可能值，将输出连接起来，网络自己学习它需要什么样的参数</strong></p><p>原生的inception模块如下如图所示</p><blockquote><p>1 . 采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合；</p><p>2 . 之所以卷积核大小采用1<em>1、3</em>3和5*5，主要是为了方便对齐。设定卷积步长stride=1之后，</p><p>只要分别设定padding =0、1、2，采用same卷积可以得到相同维度的特征，然后这些特征直接拼接在一起；</p><p>3 . 文章说很多地方都表明pooling挺有效，所以Inception里面也嵌入了pooling。</p><p>4 . 网络越到后面特征越抽象，且每个特征涉及的感受野也更大，随着层数的增加，3x3和5x5卷积的比例也要增加</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308221238.png" alt=""></p><p>改进型inception模块使用了1x1的卷积，解决了原生模块计算量爆炸的问题</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308221427.png" alt=""></p><h5 id="（三）论文要点">（三）论文要点</h5><p>（1）.深度，层数更深，文章采用了9组inception模块，22层。为了避免梯度消失的问题，增加了两个辅助分类器，用来在反向传播过程中为前面的层注入梯度</p><p>（2）.宽度，增加了多种核 1x1，3x3，5x5。多尺度卷积核并行，总有一个能捕捉到想要的特征。使用1x1卷积核大大降低计算量</p><p>（3）网络最后采用了average pooling来代替全连接层，想法来自NIN,参数量仅为AlexNet的1/12,性能优于AlexNet，事实证明可以将TOP1 accuracy提高0.6%。但是，实际在最后还是加了一个全连接层，主要是为了方便finetune</p><p>（4）网络中依然使用了Dropout技术</p><h4 id="InceptionV2-V3">InceptionV2/V3</h4><h5 id="（一）综述-2">（一）综述</h5><p>卷积神经网络在计算机视觉领域大放异彩，但是在加宽加深模型的同时，要考虑到计算效率，不能一味地增大。考虑到边缘设备，移动设备。</p><p>提出了四个设计准则：顺我者昌，逆我者亡</p><blockquote><p>a.避免过度降维或收缩特征bottleneck，特别是在网络浅层</p><p>b.特征越多，收敛越快：eg给你更多猫的特征，你就能判断他是一直猫</p><p>c.3x3和5x5卷积核之前用1x1卷积核进行升维，信息不会丢失</p><p>d.均衡网络的宽度和深度，两者同时提升，即可升高性能，又能提高计算效率</p></blockquote><h5 id="（二）InceptionV2">（二）InceptionV2</h5><p>InceptionV2用两个3x3卷积核代替了5x5的卷积核</p><p><strong>增加网络深度，提高网络的非线性表达能力，保持感受野范围的同时又减少了参数量</strong></p><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308223452.png" width=400/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308223514.png" width=400/></center>除此之外，InceptionV2还提出了大名鼎鼎的Batch Normalization方法<p><a href="https://newblog.leohu.me/2022/03/07/cs231n%E4%BC%98%E5%8C%96%E5%99%A8BN/#BN%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">BN层看这篇笔记吧</a></p><h5 id="（三）InceptionV3">（三）InceptionV3</h5><p>（1）不对称卷积+扩展滤波器组</p><p>不对称卷积也起到减少计算量，增加网络深度的作用。但这种卷积在靠前的层效果不好，feature在12-20之间比较合适</p><p>扩展滤波器组起到加宽网络，升维的作用。在最后分类层之前，用改模块扩展特征维度，生成高维稀疏特征</p><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308225145.png" width=350/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220308225211.png" width=400/></center><p>（2）Label Smoothing</p><p>对于一个三分类问题，想要得到一个结果（1，0，0），网络会无所不用其极的增加想要的类别的logit分数，正确类别的分数会一味增大，直到正无穷，这样就使得模型死记硬背，可能造成过拟合。而使用label smoothing之后，或许只需要当结果为0.9的时候结束概率的增加，看似给了错误一点机会，其实是避免模型的盲目自信</p><h2 id="2-ResNet">2.ResNet</h2><h5 id="（一）综述-3">（一）综述</h5><p>文章首先提出了一个问题，能不能通过简单的堆叠网络层数，就能得到一个学习能力强大的网络?</p><p>事实是，随着网络的加深，会出现退化问题，也即是准确率会先上升到饱和，如果再增加网络深度，准确率就会下降。网络退化既不是由过拟合造成的，也不是由梯度消失造成。</p><p>因此，作者提出了一种解决办法：通过增加恒等映射(skip connection)的数据通道，使得在增加模型深度的同时，至少不会在训练集上变得更差</p><blockquote><p>大不了，我什么也不做，直接从恒等映射通道跳到下一个残差块</p><p>什么也不做，有时候很重要</p></blockquote><p>如果说传统神经网络想要拟合的函数是H(x)，那么引入恒等映射后，学习目标就变成了F(x)=H(x)-x，作者认为拟合H(x)和F(x)的效果是相似的，但是拟合F(x)的单独更低</p><blockquote><p>整个网络只需要学习输入和输出差别的那一部分，简化学习的目标和难度</p></blockquote><h5 id="（二）ResNet结构">（二）ResNet结构</h5><p>朴素版本的残差块如下所示</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220309225124.png" alt=""></p><p>作者针对18层和34层的网络做了实验</p><p><strong>未使用</strong>skip connection(恒等映射)的网络，层数越深，性能越差</p><p><strong>使用了</strong>skip connection的网络的网络，层数越深，性能越好</p><blockquote><p>Plain-networks使用了BN层，在训练过程中前向传播的时候，可以确保数据不会全挤在同一个数附近，也就是有非零方差；而在反向传播的时候，范数大小看起来也是健康的，<strong>所以网络退化问题不是又梯度消失导致的</strong></p><p>对于Plain-networks，作者使用了大量的数据，使用了多轮迭代，依旧不能解决网络退化问题，<strong>所以网络退化问题不是过拟合导致的</strong></p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220309225310.png" alt=""></p><p>为了节省计算效率，论文中还提出了三层的残差学习单元，形成了两头宽，中间窄的残差学习单元</p><blockquote><p>两头的1x1卷积，前一个是实现降维操作，后一个是实现升维操作。增加了网络的深度，减少了计算量，增加了网络的非线性表达能力</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220309230206036.png" alt=""></p><p>不同层数的ResNet</p><blockquote><p>resnet后边跟的数字代表有权重的层的数目</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220309230530174.png" alt=""></p><h5 id="（三）总结一下-ResNet能够解决网络退化的原因">（三）总结一下 ResNet能够解决网络退化的原因</h5><p>1.深层梯度回传流畅</p><blockquote><p>恒等映射一路的梯度是1，把深层的梯度注入底层，防止梯度消失，<strong>没有中间商层层盘剥</strong></p></blockquote><p>2.类比其它机器学习模型</p><blockquote><p>LSTM的遗忘门，残差有用就保留记忆，残差没用就恒等映射</p></blockquote><p>3.传统的线性结构网络难以拟合恒等映射</p><blockquote><p>a.高度非线性会造成不可弥补的信息损失，使用恒等映射，直接找回损失</p><p>b.什么都不做有时候很重要，普通的神经网络总会训练点什么出来</p><p>c.恒等映射可以让模型自行选择要不要更新</p></blockquote><p>4.ResNet其实相当于几个浅层网络的集成</p><blockquote><p>下边这个图应该可以说清楚了，有点densenet的感觉</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220309232827511.png" alt=""></p></blockquote><h2 id="3-MobileNet系列">3.MobileNet系列</h2><h3 id="a-MobileNetV1">a.MobileNetV1</h3><h5 id="1-深度可分离卷积">1.深度可分离卷积</h5><p>MobileNetV1的核心就是深度可分离卷积。深度可分离卷积分为两个步骤：Depthwise卷积+PointWise卷积</p><blockquote><p>Depthwise卷积提取长宽方向的信息，PointWise卷积提取跨通道的信息</p></blockquote><p>Depthwise卷积如下图所示</p><blockquote><p>不用于常规的卷积操作，Depthwise卷积类似于将输入的卷积层沿着通道平面切开，每一个通道平面都有自己的卷积核。将各个卷积核卷积后生成的feature map像作业本一样堆起来传到PointWise</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310224056.png" alt=""></p><p>PointWise卷积如下图所示</p><blockquote><p>使用1x1xC的卷积核沿着输入feature map通道深度的方向捕获跨通道的信息，像一把锥子一样刺穿feature map。完成信息的跨通道融合，牛逼就完事儿了。</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310224529.png" alt=""></p><p>使用深度可分离卷积，可以显著的减少参数，减少计算量</p><p>下图左侧是标准卷积乘法计算量，右侧是深度可分离卷积的乘法计算量</p><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310225245.png" width=350/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310225213.png" width=350/></center><p>当卷积核大小为3x3的时候，计算量会减少到约为原来的1/9~1/8</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310225424.png" alt=""></p><h5 id="2-V1深度可分离卷积块结构">2.V1深度可分离卷积块结构</h5><p>使用了ReLU6非线性激活函数，作者认为<strong>ReLU6作为非线性激活函数，在低精度计算下具有更强的鲁棒性</strong></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310225643.png" alt=""></p><p>MobileNet的网络结构如下图所示</p><blockquote><p>S2表示用步长为2的卷积代替池化来进行下采样</p><p>整个网络有13组深度可分离卷积，一共有28层</p><p>最后采用平均池化层将feature变成1x1，根据预测类别大小加上全连接层</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220310231325105.png" alt=""></p><h3 id="b-MobileNetV2">b.MobileNetV2</h3><h5 id="MobileNetV1局限">MobileNetV1局限</h5><p>MobileNetV1未使用残差连接</p><p>并且很多Depthwise训练出来的卷积核是0</p><blockquote><p>a.卷积核权重数量以及通道数太少，就像三维世界的人无法理解四维世界</p><p>b.ReLU函数在低维空间容易造成信息丢失</p></blockquote><p><strong>这就解释了为什么深度卷积的卷积核有不少是空</strong>。</p><p>针对这个问题，可以这样解决：既然是ReLU导致的信息损耗，<strong>将ReLU替换成线性激活函数</strong>。</p><h5 id="Linear-bottleneck">Linear bottleneck</h5><p>在1x1升维、在高维空间进行Depthwise操作均使用ReLU6激活函数</p><p>而在1x1xC的PointWise卷积之后采用了线性激活函数</p><blockquote><p>神经网络的强大能力来源于非线性激活函数，自然不能全换</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220310235538.png" alt=""></p><h5 id="Expansion-layer">Expansion layer</h5><p>使用1x1卷积进行升维度，解决ReLU函数在低维度信息丢失问题</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220311000217.png" alt=""></p><h5 id="Inverted-residuals">Inverted residuals</h5><p>下图右侧倒残差结构，中间大，两头小</p><p>像ResNet一样引入了<strong>shortcut结构</strong></p><p>从拟合函数变成了拟合残差</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220311000317.png" alt=""></p><h5 id="打个总结">打个总结</h5><p>左边是v1的block，没有Shortcut并且带最后的ReLU6</p><p>右边是v2的加入了1×1升维，引入Shortcut并且去掉了最后的ReLU，改为Linear。</p><blockquote><p>步长为1时，先进行1×1卷积升维，再进行深度卷积提取特征，再通过Linear的逐点卷积降维。将input与output相加，形成残差结构。</p><p>步长为2时，因为input与output的尺寸不符，因此不添加shortcut结构，其余均一致</p></blockquote><center class="half"><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220311001142.png" width=350/><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220311001156.png" width=350/></center>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs231n之BN/优化器</title>
      <link href="/2022/03/09/cs231n%E4%BC%98%E5%8C%96%E5%99%A8BN/"/>
      <url>/2022/03/09/cs231n%E4%BC%98%E5%8C%96%E5%99%A8BN/</url>
      
        <content type="html"><![CDATA[<h2 id="1-BN"><a href="http://1.BN">1.BN</a></h2><p>CS231N课程中对BN层的解释是，将数据分布强行转为标准正态分布，也即均值为0，标准差为1的分布</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306222044.png" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306222552.png" alt=""></p><p>课程中对BN的讲解很泛，听了两遍，依然觉得模模糊糊，来看下郭耀华大佬的</p><h4 id="Internal-Covariate-Shift">Internal Covariate Shift</h4><p>对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层</strong></p><h4 id="BN基本思想">BN基本思想</h4><p>BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值</strong>（就是那个x=WU+B，U是输入）<strong>随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度</strong></p><p>一言以蔽之：<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题</strong></p><h4 id="BN好处">BN好处</h4><p><strong>①</strong> <strong>提升了训练速度，加速收敛过程o，改善梯度，远离饱和区</strong></p><p><strong>②类似于Dropout的正则效果，避免过拟合</strong></p><p><strong>③调参过程中可以使用大的学习率</strong></p><h4 id="注意">注意</h4><p>在训练过程中使用minibatch的均值和方差，而在前向推理过程中使用全局的均值和方差</p><h2 id="2-优化器">2.优化器</h2><h3 id="1-SGD">1.SGD</h3><h5 id="原生的特点">原生的特点</h5><p>a.在梯度较大的方向上发生振荡，但这种振荡并不能仅通过减小学习率来解决</p><blockquote><p>因为学习率一小，正确方向的梯度也减小了</p></blockquote><p>b.原生的SGD容易陷入局部最优点也就是鞍点</p><p>c.SGD的梯度来自mini-batch，有噪声</p><h5 id="优化">优化</h5><p>引入Momentum动量。动量能起到平均平滑的作用，每次都抵消掉振荡的部分，让该更新的地方更新。</p><p>下图中vx就是动量，初始为0，到rho为0时，和原生的SGD没有明显区别。rho通常去0.9/0.99，表示的意思是对过去影响的衰减</p><blockquote><p>引入动量之后，实际上把上一步的影响/惯性纳入到了当前步的决策当中</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306225743.png" alt=""></p><p>Nesterov，另一种动量，棋高一手，先一步感知，预测未来</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220306230313348.png" alt=""></p><h3 id="2-AdaGard">2.AdaGard</h3><p>在SGD的基础上，在梯度较大的振荡方向加入惩罚项</p><blockquote><p>But,当惩罚项过于大的时候，后边可能不再更新</p></blockquote><p>下图中，dx就是梯度，梯度很大，则grad_squared也很大，所以分母也很大</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306230604.png" alt=""></p><h3 id="3-RMSProp">3.RMSProp</h3><p>在AdaGrad基础上，对grad_squard引入了衰减因子<code>decay_rate</code></p><blockquote><p>也即保留多少之前的惩罚项，保留多少现在的惩罚项</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306230841.png" alt=""></p><h3 id="4-Adam">4.Adam</h3><p>结合了第一动量和第二动量</p><blockquote><p>fitst_moment初始化为0，预热较慢，设置first_unbias项，beta1是一个小于1的数，因此一开始，first_unbias可以有一个不小的值。随着t的增加，分母逐渐变大。</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/image-20220306231200514.png" alt=""></p><h2 id="3-学习率">3.学习率</h2><p>学习率过大，振荡</p><p>学习率过小，难以快速收敛</p><h2 id="4-正则话">4.正则话</h2><h3 id="L1和L2">L1和L2</h3><h3 id="Dropout">Dropout</h3><p>引入稀疏性，打破神经元之间的联合依赖适应性</p>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> cs231n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs231n之激活函数/数据预处理/权重初始化/</title>
      <link href="/2022/03/07/cs231n%E8%AF%BE%E7%A8%8B%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/03/07/cs231n%E8%AF%BE%E7%A8%8B%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>1.梯度下降指的是使得损失函数下降，而不是梯度本身下降</p><p>2.全部数据一起传输进去神经网络是不经济的，内存吃不消，以mini-batch输入神经网络</p><p>3.激活函数为模型引入了非线性因素，解决线性模型所不能解决的问题</p><h2 id="1-激活函数">1.激活函数</h2><p>其实没啥好说的，说来说去就是那几个点，一般也是问Relu函数有啥作用</p><p><a href="https://www.cnblogs.com/guoyaohua/p/8727509.html">郭耀华大佬的博客</a>从另外的角度总结了下Relu激活函数，这里做一个摘抄</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306220128.png" alt=""></p><h2 id="2-数据预处理（特征工程）">2.数据预处理（特征工程）</h2><p>标准化处理数据：损失函数对w的微笑改变不那么敏感，更容易优化</p><p>几个经典网络采取的措施</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306220549.png" alt=""></p><h2 id="3-权重初始化">3.权重初始化</h2><p>所有权重不能初始化为同一个常数，否则无法打破“对称性”</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20220306220813.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 考研复试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研复试 </tag>
            
            <tag> cs231n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Fail2ban防ssh暴破</title>
      <link href="/2022/01/03/fail2ban%E9%98%B2ssh%E6%9A%B4%E7%A0%B4/"/>
      <url>/2022/01/03/fail2ban%E9%98%B2ssh%E6%9A%B4%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装fail2ban">1.安装fail2ban</h4><p>CentOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install fail2ban</span><br></pre></td></tr></table></figure><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fail2ban</span><br></pre></td></tr></table></figure><h4 id="2-新建一个sshd的配置">2.新建一个sshd的配置</h4><p>可以使用finalshell直接访问到路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fail2ban/jail.d/sshd.local</span><br></pre></td></tr></table></figure><p>eg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ssh-iptables]</span><br><span class="line">enabled  = true</span><br><span class="line">filter   = sshd</span><br><span class="line">action   = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath  = /var/log/secure</span><br><span class="line">maxretry = 6   # 最多连接6次失败</span><br><span class="line">bantime  = 6048000   # 禁止70天（按秒计算）</span><br></pre></td></tr></table></figure><p>如果是<strong>debian</strong>或<strong>ubuntu</strong>系统，<strong>logpath</strong>需要修改成/var/log/auth.log<br>保存这个文件。</p><h4 id="3-启动">3.启动</h4><p>CentOS 7等使用systemctl方式启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start fail2ban.service</span><br></pre></td></tr></table></figure><p>老的init启动脚本方式的启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service fail2ban start</span><br></pre></td></tr></table></figure><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/fail2ban start</span><br></pre></td></tr></table></figure><h4 id="4-检查进程，防火墙是否生效">4.检查进程，防火墙是否生效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语_小作文素材</title>
      <link href="/2021/12/13/a%E5%B0%8F%E4%BD%9C%E6%96%87%E7%B4%A0%E6%9D%90/"/>
      <url>/2021/12/13/a%E5%B0%8F%E4%BD%9C%E6%96%87%E7%B4%A0%E6%9D%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基础">基础</h3><p>905 /619 房间号，楼栋号，校园</p><blockquote><p>I am a student/sophomore living in room 123, the first student dormitory of our university. （ 表 明 目 的 ） I write this letter to express my dissatisfaction with the guys living in room 121</p></blockquote><p>in response to,xxx</p><blockquote><p>被动建议</p></blockquote><p>as a responsible/liable and warm-hearted reader/student/would-be graduate(临近毕业的学生)</p><p>I feel obliged to give some advice about how improve the management of</p><blockquote><p>主动建议</p></blockquote><p>cannot help doing sth 情不自禁做某事</p><p>cannot wait to do迫不及待做某事</p><h3 id="个人习惯">个人习惯</h3><p>I’m a bit of a neat freak, and I always have personal items organized, thus…</p><blockquote><p>我有一点洁癖，总是喜欢将个人物品收放整齐</p></blockquote><p>This has made my roommates and me unable to focus attention on academic study and have a good sleep.</p><p>Live stream v.直播 n.一场直播</p><p>Live stream the wedding 直播这场婚礼</p><p>Only to … 却…</p><blockquote><p>I arrived at the station, only to find that the train had left.却发现火车已经开走了</p></blockquote><p>in some restaurant famous for its local cuisine 当地有名的菜</p><p>be named after:以。。。为名命</p><blockquote><p>Tianfu Square,which is named after a line of verse written by known poet from Tang dynasty</p><p>天府广场以一行诗名命</p></blockquote><p>large music fountain show 大型的音乐喷泉秀</p><p>full of chinese elements 充满中国元素</p><p>have supper 吃晚餐</p><p>best wishes最美好的祝愿</p><p>be initiated by … 由… 发起</p><p>answer the global call  响应全球号召</p><p>conserve energy and reduce emission 节能减排</p><p>turn down the tap 关小水龙头</p><h3 id="个人品质">个人品质</h3><p>Those who possess good communication skills and organizational capabilities are preferred.</p><p>Also, the qualities of optimism, integrity,and persistence are highly valued.</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研英语 </tag>
            
            <tag> 小作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408_考频统计</title>
      <link href="/2021/12/05/408%E8%80%83%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
      <url>/2021/12/05/408%E8%80%83%E9%A2%91%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="计组">计组</h3><p><img src="https://edu-image.nosdn.127.net/f8c8dcba37e04a1c85919c3e2d6bbd55.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 考频统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语_大作文素材</title>
      <link href="/2021/11/29/a%E5%A4%A7%E4%BD%9C%E6%96%87%E7%B4%A0%E6%9D%90/"/>
      <url>/2021/11/29/a%E5%A4%A7%E4%BD%9C%E6%96%87%E7%B4%A0%E6%9D%90/</url>
      
        <content type="html"><![CDATA[<h3 id="基础内容">基础内容</h3><p>million百万</p><blockquote><p>1300万：13 million；700万：7million</p></blockquote><p>ton 吨</p><blockquote><p>10吨：10tons</p></blockquote><p>大一 freshman；大二 sophomore；大三 junior；大四 senior</p><p>public transport 公共交通</p><p>traffic congestion 交通杜塞</p><p>infrastructure基础设施建设 to participate in City construction</p><p>shared bikes共享单车</p><p>dweller居民</p><p>sth become the first choice for sb to do</p><blockquote><p>As the gathering places for social and histroical culture, museums have become the the first choice for cicizens to visit and learn</p></blockquote><h3 id="经济类">经济类</h3><p>(随着经济的繁荣发展)</p><p>we tend to think of the decades following World War 2 as a time of prosperity and growth</p><blockquote><p>the comes of economical prosperity and growth</p><p>with the coming of economical prosperity and growth</p><p>with the fast economic development these years, Chinese food industry has experienced a dramatic growth</p></blockquote><p>The advances in globalization and the information technology revolution</p><blockquote><p>全球化的发展与信息科技革命</p></blockquote><p>(经济条件不是该趋势流行的唯一的因素)</p><p>Economic condition is only a stimulus for the trend toward efficient livin g</p><p>(这些因素对。。施加了巨大的影响)</p><p>These factors come to exert enormous influence on the…</p><p>(掩盖真象)</p><p>sb mask the fact that</p><p>经济：快速发展-》高薪工作岗位</p><blockquote><p>economy and technology have developed fast/well-paid jobs</p></blockquote><p>政策：优厚政策–学费减免reducing tuition/福利分房granting apartments</p><blockquote><p>Chinese government and corporations/enterprises have introduced highly competive policies such as reducing tuition and granting apartments</p></blockquote><p>媒体：互联网化媒体发展-》展示中国各种好</p><blockquote><p>As the Internet media boom/with XXX developing/booming, an increasing number of articles and short videos that showcase(展示) the prospects of studying, working and living in China are going viral on the web，exerting huge influence on …</p></blockquote><p>Indeed, the period of economic weakness may reinforce class divides and decrease oppprtunities to cross them–especially for young people</p><blockquote><p>经济萧条会加剧阶级分化，并减少阶级弥合的机会，对于年轻人尤其如此。</p></blockquote><p>due to the incrasing household income of Chinese families，Chinese studens‘ spending power are greater</p><blockquote><p>家庭收入的增长促进了消费能力的增长</p></blockquote><p>购买力 spending power</p><p>家庭收入 the household income of Chinese families</p><p>可支配收入 the disposable income</p><p>The past decade has witnessed a tremendous 巨大的 progress in information technology</p><blockquote><p>修辞：时间段 +has/have witnessed + 某种变化</p><p>The past forty years have witnessed the dramatic change of China.</p></blockquote><p>China has undergone an unprecedented urbanlization during the past twenty years with millions of new work positons created</p><blockquote><p>前所未有的城市化进程，数百万计的工作岗位</p></blockquote><p>enjoy the fruits of urbanlization</p><blockquote><p>享受城市化进程的福利</p></blockquote><p>移动支付 mobile payment</p><p>刷卡 card /bank card /credit card</p><blockquote><p>刷卡支付card payment</p></blockquote><p>现金 cash</p><blockquote><p>现金支付cash payment</p></blockquote><p>移动支付供应商 mobile payment providers</p><blockquote><p>Alipay、Wechat Pay、Apple Pay、Google Pay</p><p>提供offer\present,presen的生僻含义“提供&quot;</p></blockquote><blockquote><p>Secondly, there is no denying that mobile payment providers sometimes present/offer coupons. Thus, this saves consumers a sum of money</p></blockquote><p>降低…的风险 lower the risk of doing sth</p><blockquote><p>降低考试失败的风险 lower the risk of failing a test/exam</p></blockquote><p>All the advantages have made mobile paymentthe predominant占主导地位的 payment method</p><blockquote><p>The mainstream payment method</p><p>the main/major payment method</p></blockquote><p>Because of all the advantages, mobile payment has come to take the lead.</p><p>Come to do 逐渐做到某事/怎么样</p><p>Over consumption 过度消费</p><p>Excessive consumption超前消费</p><blockquote><p>花呗，从心理上促进你的消费</p></blockquote><p>the dramatic economic development allows Chinese people to develop a strong desire for possessing and using more and more better things.</p><p>Although exchanging festival gifts, as a way of maintaining friendly sentiment, should be carried forward, one should keep the expenditure within the range that one can afford,avoiding excessive consumption.</p><blockquote><p>交换礼物维系友谊的传统值得传承，但是花销应当在一个人可承受的范围内</p></blockquote><p>“price” occupies the largest part, mainly because most university students depend financially on their parents and thus cannot afford a pricy high-end smartphone</p><blockquote><p>学生经济不独立=经济上依赖父母=没有直接收入来源</p><p>high-end高端smartphone</p></blockquote><p>financially secure经济保障</p><p>young graduates are more likely to prioritize personal fulfillment in their work</p><blockquote><p>年轻人优先考虑工作中的成就感</p></blockquote><p>with the fast social development, Chinese people’s living conditions have improved dramatically</p><h3 id="科技类">科技类</h3><p>As the smartphone industry is highly advanced, the performance gap among different smartphones of the same tier becomes small/negligible.</p><blockquote><p>the same tier同代，当前等级</p><p>first-tier city一线城市</p><p>second-tier city二线城市</p></blockquote><blockquote><p>智能手机工业发展，不同智能鸡的性能相差很小</p><p>Negligible 可忽略不计的</p><p>XX industry某产业/行业/工业</p><p>XX gap</p><p>Wealth gap 贫富差距</p><p>Generation gap 代沟</p><p>Performance gap 性能差距</p></blockquote><p>Performance in taking photos 拍照性能</p><p>Camera’s performance and screen size are also two main factors, the reason may be that a powerful camera allows students to record their university life better, while a large screen makes it more convenient to attend online courses上网课 and play games.</p><p>the advancing technology</p><blockquote><p>不断进步的技术</p><p>because of the advancing technology, electronic products become more varied and more powerful.</p></blockquote><p>Living conditions 生活水平 Living standards 生活标准 Quality of life 生活质量</p><h3 id="健康类">健康类</h3><p>生病 develop a disease like cancer and high blood pressure</p><p>staple foods 主食</p><p>physical appearance 外形</p><p>心脏病 heart attack</p><p>抑郁症 depression</p><p>Therefore, cashless payment helps lower the risk of developing certain diseases</p><p>bacteria细菌</p><blockquote><p>Finally, it cannot be ignored that there are a variety of bacteria on cash.</p></blockquote><p>Some students spending much time using smartphones develop physical and/or mental diseases</p><blockquote><p>physical and/or mental diseases精神 心理上的问题</p></blockquote><p>Develop a disease 患某种疾病</p><p>Physical disease 身体疾病</p><p>Mental disease 精神疾病</p><p>obesity 肥胖病</p><p>poor digestionn 消化不良</p><p>高血压 high blood pressure</p><p>心脏病 heart attack</p><p>癌症 cancer</p><h3 id="文学类">文学类</h3><p>经典文学 classical literature</p><p>人物传记 biography</p><p>历史政治history and politics</p><p>科幻小说 science fiction</p><h3 id="教育类">教育类</h3><p>The best jobs will require workers to have more and better education to make themselves above average</p><blockquote><p>教育使人脱离平庸/脱颖而出</p></blockquote><p>compulsory education</p><blockquote><p>the populatization of complusory education has enlarged people’s vision and encouraged them to pursue/seek sanem diverse/corlouful career paths as citizens.</p></blockquote><p>public cultural undertakings 公共文化事业</p><p>strengthen the cultural awareness of oublic and enhance national cohesion增强文化意识，提高民族凝聚力</p><p>begin to pursue the spiritual enjoyment 追求精神享受</p><p>cultural development and prosperity文化发展和繁荣</p><h3 id="环保类">环保类</h3><p>The economic booms has brought with it severe envirinmental problems</p><blockquote><p>经济的增长带来了严重的环境问题</p><p>the buttery problems 电池污染</p></blockquote><p>environmental pollution and public health crisis</p><blockquote><p>环境污染和公共健康危机</p></blockquote><p>Clear waters and green mountains are as good as mountains of gold and silver.</p><p>Lucid waters and lush mountains are invaluable assets</p><blockquote><p>上面两句：绿水青山就是金山银山</p></blockquote><p>electronic garbage and plastic garbage</p><blockquote><p>电子垃圾和塑料垃圾</p></blockquote><p>智能手机 smartphones，笔记本电脑 laptop，家用电器 home appliance</p><p>外卖餐盒takeout box，塑料袋 plastic bag，软饮料包装 softdrink bottle，快递包装 package</p><h3 id="交通出行">交通出行</h3><p>trip尤其指代短途旅行，而travel可以指带出行和旅行，其含义最广。</p><blockquote><p>commute特质通勤，上下班</p></blockquote><p>Bike sharing /sharing bike /shared bike(bicycle) 共享单车</p><p>public transportation system公共交通系统</p><h3 id="其他类">其他类</h3><p>(努力终有回报) All your efforts and perseverance paid off.</p><p>help you adapt to the college life, several practical suggestions are offered.</p><p>staple foods 主食</p><p>physical appearance 外形</p><p>重视 attach importance to / pay attention to</p><p>cultivate their mind 陶冶情操</p><p>Explore different possibilities 探索不同可能性</p><p>Miss out on opportunities to do 错过做某事的机会</p><p>the society will be more harmonious 社会和谐</p><p>among常用介词，可以表示一堆事物之间，也可以表示和紧跟着的数据有关</p><p>A and B converge on one key point</p><blockquote><p>A和B在这个观点上一致</p></blockquote><p>prospects前景</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研英语 </tag>
            
            <tag> 大作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语_大作文</title>
      <link href="/2021/11/29/a%E5%A4%A7%E4%BD%9C%E6%96%87/"/>
      <url>/2021/11/29/a%E5%A4%A7%E4%BD%9C%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-静态图首段">1.静态图首段</h2><h4 id="首段">首段</h4><p>(概述图表信息)</p><p>The chart/table illustrates the number/proportion/percentage of</p><p>(多个类)</p><p>表示1：“A” account for x%, followed by “B”(y%). C take up “z”%</p><blockquote><p>“A” accounts for 54.30%, followed by “B” (47.70%). “C” and “D” take up 23.90% and 15.80% respectively</p></blockquote><p>表示2：“A”(41%) claims the first place, followed by &quot;B“(38%) . “C” complete the top three.</p><blockquote><p>“Textbook”(41%)claims the first place, followed by &quot;popular literature“(38%) and “others”(11%). “Magazines”(10%) complete the top four.</p></blockquote><h2 id="2-动态图首段">2.动态图首段</h2><p><strong>总起</strong></p><p>The chart/table illustrates the number/proportion/percentage of</p><blockquote><p>例句</p><p>1.The chart illustrates the number of foreign students coming to China and that of Chinese students returning from abroad in a given period</p><p>2.The chart illustrates/shows/demonstrates the proportion of different types of food consumed by xx</p></blockquote><p>The chart gives information about the proportion</p><blockquote><p>The chart gives information about the proportion of three different payment methods among residents/citizens from China in a given period</p><p>Chinese residents/citizens中国居民</p></blockquote><p><strong>引用关键数据</strong>（动态图数据一般只写首尾状态，不必细节描写）</p><p>（上升下降）</p><p>可用关键词</p><blockquote><p>上升 increase[increased]/rise[rose]/grow[grew]/soar[soared]</p><p>下降 decrease[decreased]/drop[dropped]/fall[fell]/decline[declined]/reduce[reduced]</p></blockquote><p>The number of xxx increased/rose from A in 2012 to B in 2018,  <u>while the figure</u> for those B also experienced a growth/increase/rise</p><blockquote><p>两条线对比，巧用while</p><p>避免重复while the figure，动词换成名词 growth/increase/rise</p><p>数据用英文的单位，32.5万=“325 thousand”</p></blockquote><p>The percentage of meat consumed rose from 15% in 2012 to 34% in 2020, while the figures for vegetable s and staple food decreased from 28% to 22% and from 49% to 39% respectively during the same period</p><blockquote><p>respectively表示分别</p></blockquote><p>（剧烈变化）</p><p>As can be seen from the chart/table/diagram, great changes have taken place in xxx</p><p>（增长稳定）</p><p>experience a steady increase</p><h2 id="3-中间段">3.中间段</h2><p>动态图和静态图的中间段分析是具有共性的，因此总结到一块儿</p><h5 id="总起">总起</h5><p>The following factors contribute to the trends（缩减字数）</p><blockquote><p>Many factors can explain the trends, but three/two/one stand out</p></blockquote><p>The following factors contribute to the situation/circumstance/occasion reflected/shown in the chart/table</p><blockquote><p>静态图描述现状</p></blockquote><p><strong>逻辑论点论述</strong></p><p>（方式一）</p><p>Firstly, it is widely accepted that（大家普遍认为）.  As a result, xxx</p><p>Secondly, there is no denying that xxx, due to the xxxx. Thus they can xxx</p><p>Finally, it cannot be ignored that xxx. Therefore, in order to be more attractive, they</p><p>–</p><p>for example = to name only few</p><blockquote><p>逻辑思路：为什么1最高，为什么2和3比较高，为什么4最低</p></blockquote><p>（方式二）</p><p>Firstly, because of。。。。。</p><blockquote><p>electronic products become more varied and more powerful广泛且性能好</p></blockquote><p>Secondly, with the fast social development,</p><p>Finally, it cannot be ignored that xxx. Therefore, in order to be more attractive, they</p><p>–</p><p>for example = to name only few</p><p>（方式三）</p><p>Firstly, “xxxx” shares the largest part, mainly because xxxxx</p><blockquote><p>Firstly, “public transportation” shares the largest part, mainly because for a long-distance travel within a city, using public transportation saves commuters and students a great deal of money</p></blockquote><p>Secondly, xxxx is another preferred/main means（方式） of xxxxx, The reason may be that it is very convenient to xxxx, since you</p><blockquote><p>Secondly, shared bicycle is another preferred/main means of travel.The reason may be that it is very convenient to reach the place not far away, since you do not need to wait for a bus or subway train.</p></blockquote><p>Finally, as to why “xxxx” and “xxxxxx” take up a relatively small proportion, my opinion is that xxx</p><blockquote><p>Finally, as to why “driving” and “walking” take up a relatively small proportion, my opinion is that buying and maintaining a car is costly, while walking is slower than any other means.</p></blockquote><p>–</p><p>for example = to name only few</p><blockquote><p>逻辑思路：为什么1最高，为什么2和3比较高，为什么4最低</p></blockquote><p><strong>小结</strong></p><p>**All the changes mentioned above have made xxx **凑字数神器</p><blockquote><p>All the changes mentioned above have made China attractive to more and more foreign students and Chinese students studying abroad</p></blockquote><h2 id="4-尾段">4.尾段</h2><h5 id="1-动态图">1.动态图</h5><p>（1）预测走势，可能存在的问题（好的）</p><p>走势：There are goods reasons to believe that有充分的理由相信the figures will continue to rise in the future.</p><p>问题：However, problems have occurred. For example</p><blockquote><p>prefer to do … rather than do</p><p>Some universities and employers prefer to recruit foreign students or overseas returnees(原形returnee) rather those Chinese graduates who have no abroad experience/who have never been abroad</p></blockquote><p>解决：Only when these problems are properly dealt with can all young people realize their Chinese dreams</p><p>（2）预测走势，指出问题（好的）</p><p>走势：It is, in my opinion, highly possible that in the future, xxx.</p><p>问题：However, this may bring about problems such as</p><p>解决：Only when these problems are properly dealt with can</p><p>（3）图中展示的不好的问题比例走势（坏的）</p><p>（评价）负面趋势造成什么危害——破坏环境和公共健康</p><p>（建议 4 选 1 或 2）政府立法 / 媒体宣传 / 家长老师教育 / 当事人改变</p><p>（展望）社会和谐/未来光明</p><p>In my opinion,xxx poses a serious threat to the environment and public health</p><blockquote><p>Pose a serious threatto 对…造成威胁</p></blockquote><p>Therefore, our government need to xxxxxxx, while the mass media should launch campaigns to encourage consumers to xxxxx</p><blockquote><p>Our government need to urge manufacturers to extend the service life of their products, while the mass media should launch campaigns to encourage consumers to use fewer plastic-made products.</p></blockquote><blockquote><p>launch campaigns开展运动</p></blockquote><p>I believe that with these efforts, the society will be more harmonious</p><h5 id="2-静态图">2.静态图</h5><p>（1）</p><p>(评价问题)In my opinion</p><p>(指出问题)However, this also causes/presents problems</p><p>（2）如果不好写，可以对全文做个总结</p><p>In my opinion, this chart/table serves as an indirect reflection of the level of xxxx</p><blockquote><p>In my opinion, this chart/table serves as an indirect reflection of the level of the city’s public transportation system</p></blockquote><p>However, problems may occur. xxxxx</p><blockquote><p>However, problems may occur: Most citizens seldom traveling on foot may develop certain diseases such as obesity 肥胖病 and poor digestion消化不良</p></blockquote><p>Only when these problems are properly addressed can xxxx</p><blockquote><p>Only when these problems are properly addressed can every citizen live a happy life</p></blockquote><h2 id="5-实用短语">5.实用短语</h2><p>Itis widely accepted that…</p><p>There is no denying that…</p><p>It cannot be ignored that</p><p>In turn 反过来，进一步</p><blockquote><p>Finally, the population in China keeps growing, which in turn(further) adds to(promotes) the consumption of these products</p></blockquote><p>The population in China = Chinese population = the number of Chinese people/citizens/residents</p><p>Living conditions 生活水平 Living standards 生活标准 Quality of life 生活质量</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研英语 </tag>
            
            <tag> 大作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语_小作文</title>
      <link href="/2021/11/22/a%E5%B0%8F%E4%BD%9C%E6%96%87/"/>
      <url>/2021/11/22/a%E5%B0%8F%E4%BD%9C%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>今年可能考 建议信/回复咨询信/通知</p><h2 id="1-落款">1.落款</h2><p>关系好：yours Li Ming</p><p>关系一般一点：Truly yours Li Ming</p><p>关系更一般一点：Sincerely/Respectfully yours Li Ming</p><h2 id="2-开头-结尾">2.开头/结尾</h2><h5 id="1-感谢信">1.感谢信</h5><p>I am writing to extend my heartfelt gratitude to you for your warm reception during my stay in the Cultural exchange program in America.</p><p>–</p><p>Again，your help and kindness are greatly appreciated from my bottom of my heart</p><h5 id="2-建议信-推荐信">2.建议信/推荐信</h5><p><strong>Begin</strong></p><p>（嘘寒问暖）</p><p>It’s been more than a month since we met last time. How’s everything going?</p><p>（表达目的）</p><p>I write to ask whether you cloud give me some proper advice/suggestions on the practice of oral English.</p><p><strong>END</strong></p><p>So I would appreciate it much if you point out my problems/give me a hand and offer some advice. Look forward to your reply.（祈使句，相当于I look forward to your reply）</p><p>Please feel free to write to me if you have further questions</p><h5 id="3-抱怨信">3.抱怨信</h5><p><strong>Begin</strong></p><p>I am a student/sophomore living in room 123, the first student dormitory of our university. （ 表 明 目 的 ） I write this letter to express my dissatisfaction with the guys living in room 121</p><p><strong>END</strong></p><p>（表达谢意+期待回复）I would appreciate it much if our university could help maintain a harmonious living environment.</p><h2 id="3-中间填充内容">3.中间填充内容</h2><h5 id="1-地点">1.地点</h5><p>Anxihu Wetland Park</p><p>Baoshan People’s Square/Park</p><h5 id="2-剧集">2.剧集</h5><p>American TV plays/drams/serials</p><blockquote><p>Friends、The Big Bang Theory</p></blockquote><h5 id="3-其它补充">3.其它补充</h5><p>Our friendship will never fade away whereever I go.</p><p>Put a word in the conversations/disscussion/debate</p><p>pay attention to/attach importance to</p><p>so as to do 以便于做某事</p><blockquote><p>so as to deal with personal information leakage, cyber theft and other challenges facing every student</p><p>cyber fraud 网络诈骗</p></blockquote><p>as to how:至于如何</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研英语 </tag>
            
            <tag> 小作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408_计算机组成原理_第3章</title>
      <link href="/2021/08/29/408_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E7%AC%AC3%E7%AB%A0/"/>
      <url>/2021/08/29/408_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E7%AC%AC3%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-存储器相关概念">1.存储器相关概念</h2><p>1.RAM(Ramdom Access Memory)和ROM的存取方式都是随机存取的</p><p>2.主存和Cache之间的的数据调动是由硬件自动完成的，对于所有程序员都是透明的；而主存和辅存之间的数据调动是由硬件和操作系统共同完成，对于应用程序员是透明的</p><p>3.DRAM和SRAM</p><blockquote><p>DRAM采用地址复用技术，而SRAM不采用</p></blockquote><blockquote><p>DRAM用于主存，每个存储元件是造成本更低，集成度高，功耗低</p><p>SRAM用于Cache，每个存储元制造成本高，集成度低，功耗大</p></blockquote><blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829224742.png" alt=""></p></blockquote><blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829224951.png" alt=""></p></blockquote><p>4.DRAM电容上电荷最多只能能维持2ms，因此需要定期进行刷新，有三种刷新方式</p><blockquote><p>1.集中刷新：利用一段固定时间，依次对所有存储器进行刷新，存在死区(即此刻无法进行任何读写操作)</p><p>2.分散刷新： 每行读存取周期之后就紧接着刷新，相当于存取周期翻倍了，不存在死区。</p><p>3.异步刷新：本质是分散了1中的死区时间，将刷新间隔2ms除以行数，得到两次刷新操作之间的间隔t，每隔t就产生一次刷新请求。</p></blockquote><h2 id="2-主存储器和CPU连接">2.主存储器和CPU连接</h2><h4 id="1-存储器芯片的输入输出信号">1.存储器芯片的输入输出信号</h4><blockquote><p>CS：Chip Select</p><p>CE：Chip Enable</p><p>字符顶部加横线表示低电平有效</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829230930.png" alt=""></p></blockquote><h4 id="2-主存容量的扩展">2.主存容量的扩展</h4><ul><li><p>位扩展</p><p>利用多个低位数芯片组合到一起实现对字长进行扩充，增加存储字长</p><p>对于位扩展而言，某一时刻选中所有的芯片，片选信号CS要连接到所有芯片</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829230339.png" alt=""></p></li><li><p>字扩展</p><p>利用了MAR中空闲的高位，增加了存储器中字的数量</p><blockquote><p>1.使用了译码器的选择芯片的方法叫做<code>译码片选法</code>，下图中展示的是2-4译码器，将输入的两位地址信号映射为4个输出信号，对应选择四片不同的芯片。</p><p>2.不适用译码器，直接用地址线选择芯片的方法叫做<code>线选法</code>，因为每次指令只能选择一块芯片，所以线选并不能充分利用存储空间，会造成地址资源浪费</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829230908.png" alt=""></p></li><li><p>字位同时扩展法</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829231748.png" alt=""></p></li></ul><h4 id="3-译码器">3.译码器</h4><p>译码器后面的小圆圈表示<code>非</code>运算，当取<code>非</code>的时候对应低电平有效的芯片</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829232125.png" alt=""></p><p>地址信息是通过电信号输送的，刚开始送出的时候，电流可能不稳定，使用<code>使能端</code>,保证片选的时候信号是稳定的</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829232448.png" alt=""></p><h2 id="3-多模块存储器和双端口RAM">3.多模块存储器和双端口RAM</h2><p>1.对于DRAM芯片而言，因为其破坏性易失性的特性，常常需要恢复原有的数据，而恢复的周期通常比较长。</p><p>2.单体多字存储器本质就是增加了容量而已，对于不连续的数据读取，工作速度会很慢</p><p>3.高位交叉编址是一种串行存取的顺序存储器，每次读取从每一块芯片的上到下读起，每读完一个地址都得等其恢复，速度很慢</p><p>4.低位交叉编址很好的利用了流水线的特性，大大增加了存取的速度</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210829233307.png" alt=""></p><h2 id="4-Cache">4.Cache</h2><h4 id="1-程序访问的局部性原理">1.程序访问的局部性原理</h4><p>时间局部性是指最近的未来要用到的东西，很可能是现在正在使用的东西</p><p>空间局部性是指最近的未来要用到的东西，很可能和现在正在使用的东西在空间上是邻近的</p><h4 id="2-Cache基本工作原理">2.Cache基本工作原理</h4><p>1.Cache仅保存主存中活跃的若干副本，缓解CPU与主存之间的速度矛盾</p><p>2.Cache并没有增加存储系统容量，其内部存储的仅仅是主存中元素的副本</p><p>2.CPU与Cache/主存之间的数据交换都以字为单位，而Cache和CPU之间的数据交换以块为单位</p><blockquote><p>主存的块也叫做“页/页框/页面”，Cache的块又叫做“行”</p></blockquote><h4 id="3-Cache与主存的3种映射关系">3.Cache与主存的3种映射关系</h4><ul><li><p>全相联映射</p><p>主存的每一块可以装入Cache的任意位置，这样的做的话，Cache块碰撞率低，空间利用率高，缺点是tag位比较的速度很慢。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux关闭防火墙</title>
      <link href="/2021/08/28/Linux%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>/2021/08/28/Linux%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Ubuntu-Debian">1.Ubuntu/Debian</h2><p>安装ufw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ufw</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure><p>开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p>查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><h2 id="2-CentOS">2.CentOS</h2><p>查看防火墙状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>停止firewall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p>禁止firewall开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld.service </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Azure VPS获得Root权限</title>
      <link href="/2021/08/28/Azure%20VPS%E8%8E%B7%E5%BE%97Root%E6%9D%83%E9%99%90/"/>
      <url>/2021/08/28/Azure%20VPS%E8%8E%B7%E5%BE%97Root%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-获得一台AZ-VPS">1.获得一台AZ VPS</h2><p>此处省略1万字</p><h2 id="2-获取权限">2.获取权限</h2><h4 id="Step1：登入1中获得VPS">Step1：登入1中获得VPS</h4><h4 id="Step2：切换用户">Step2：切换用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure><h4 id="Step3：设置root密码">Step3：设置root密码</h4><p>运行下面的命令，并输入两次设置的root密码</p><p>这里密码要记录一下，之后要用这个密码登录vps的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><h4 id="Step4：修改配置文件">Step4：修改配置文件</h4><p>这里使用vim修改<strong>sshd_config</strong>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到下面这行代码，不要去修改保持注释状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#PermitRootLogin prohibit-password   // 允许root登录，但是禁止root用密码登录（默认值在文件中是被注释掉的）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后新建一行 添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes   //允许root登录，设为yes。</span><br></pre></td></tr></table></figure><p>修改好之后记得保存</p><h4 id="Step5：重启SSH服务">Step5：重启SSH服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408_计算机组成原理_第1和2章</title>
      <link href="/2021/08/26/408_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E7%AC%AC1%E5%92%8C2%E7%AB%A0/"/>
      <url>/2021/08/26/408_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E7%AC%AC1%E5%92%8C2%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊符号">特殊符号</h2><p>Knowledge Points：知识点</p><h2 id="第一章">第一章</h2><p>1.早期的冯诺依曼机以运算器为中心，且是单处理机</p><blockquote><p>基本工作方式是：控制流驱动</p></blockquote><p>2.一个完整的计算机系统包括硬件系统和软件系统</p><p>3.三个级别的语言</p><blockquote><p>a.机器语言：又叫做二进制语言，是计算机唯一可以直接识别和执行的语言</p></blockquote><blockquote><p>b.汇编语言：是一种低级别的语言，需要通过“汇编程序”将之转换为计算机机器语言后，才能在计算机的硬件系统上使用</p></blockquote><blockquote><p>c.高级语言：诸如Python、C++之类的的语言。</p></blockquote><p>4.通常来说，高级语言会经过<code>编译程序</code>编译成汇编语言程序，然后再经过<code>汇编程序</code>操作得到机器语言程序；当然也可以直接将高级语言程序翻译成机器语言程序。</p><p>5.翻译程序、汇编程序、编译程序、解释程序的区别和联系</p><ul><li><p>翻译程序</p><p>顾名思义，就是将高级语言源程序翻译成机器语言程序(目标代码)的软件，其分为两类</p><blockquote><p>一是编译程序：将高级语言源程序一次全部翻译成目标程序(eg汇编语言程序)，源程序不变就无需重新编译。注意目标程序仍不是计算机硬件能直接执行的程序。</p><p>二是解释程序：一条一条的将源程序语句翻译成对应的机器目标代码，并立即执行。</p></blockquote></li><li><p>汇编程序</p><p>汇编程序把汇编语言翻译为机器语言程序。</p></li></ul><p>6.在CPU中，IR、MAR和MDR对各类程序员都是透明的(不可见的)</p><p>7.机器字长、指令字长与存储字长</p><blockquote><p>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，决定了计算机运算精度</p></blockquote><blockquote><p>指令字长：一个指令字中包含的二进制代码的位数</p></blockquote><blockquote><p>存储字长：一个存储单元的二进制代码的长度</p></blockquote><p>8.主频高的CPU不一定比低的块</p><blockquote><p>衡量CPU的指标很多啦，高主频的CPU处理高CPI的程序，不见得会比低主频的CPU处理低CPI的程序快</p></blockquote><hr><h2 id="第二章-数据的表示和运算">第二章 数据的表示和运算</h2><h3 id="2-定点数的表示">2.定点数的表示</h3><p>1.<strong>区别无符号数和有符号数</strong></p><blockquote><p>长8位的无符号整数可表示的数值区间是：2^8-1</p><p>注意此处的8位指的是从0到7，一共8位</p></blockquote><p>2.<strong>定点整数</strong>的小数点通常放在数值后面隐藏，即其组成为：符号位+数值部分+小数点位置(隐藏)</p><p>3.<strong>定点小数</strong>的小数点通常在符号位后面，最高数值为前边，即其组成为：符号位+小数点位置+数值部分</p><p>4.<strong>原码、反码、补码和移码</strong></p><ul><li><p><strong>真值</strong></p><p>顾名思义就是真实值的意思，这里做一点补充</p></li><li><p><strong>原码</strong></p><p>原码其实就是有符号数，由符号位+数据部分组成</p><p>若字长n+1位，则原码整数范围为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(2^n-1)\leqslant x \leqslant (2^n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818093214.png" alt="1"></p><p>若字长为n+1位，则原码小数范围为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(1-2^{-n})\leqslant x \leqslant (1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818091438.png" alt="2"></p><blockquote><p>对于小数来说，就是0.5+0.25+0.125…，使用求和公式计算出来的而已，so easy！</p></blockquote></li><li><p><strong>反码</strong></p><p>反码常用来作为原码就补码的中间过渡。<u>正数的反码=补码；负数的反码，符号位不变，数值部分全部取反。</u></p><p>若字长n+1位，则反码整数范围为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(2^n-1)\leqslant x \leqslant (2^n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818093214.png" alt="1"></p><p>若字长为n+1位，则反码小数范围为：</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(1-2^{-n})\leqslant x \leqslant (1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818091438.png" alt="2"></p><ul><li><p><strong>补码</strong></p><p>正数的补码=其原码=其反码；负数的补码=其反码的值在最低数值位再+1</p><p>补码对于真值0的表示是唯一的，只有+0才表示0</p><p>若字长n+1位，则补码整数范围为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mi>n</mi></msup><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-2^n\leqslant x \leqslant (2^n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.851062em;vertical-align:-0.13667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>整数的补码比原码在区间上多表示了一个2^n</p></blockquote><p>若字长n+1位，则补码小数范围为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mn>1</mn><mo>⩽</mo><mi>x</mi><mo>⩽</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-1\leqslant x \leqslant (1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78111em;vertical-align:-0.13667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>小数的补码比原码在区间上多表示了一个-1</p></blockquote></li><li><p><strong>移码</strong></p><p>移码智能表示整数</p><p>移码在补码基础上将符号位取反即可</p><p>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小</p></li></ul><p>5.<strong>对于第4点的补充</strong></p><ul><li>原码和反码对于真值0的表示形式是不唯一的，有+0和-0之分</li><li>补码对于真值0的表示形式是唯一的，即只有+0才表示0</li><li><code>[x]补</code>快速求<code>[-x]补</code>的方法：符号位，数值位均取反，末尾再+1</li></ul><hr><h3 id="3-定点数的运算">3.定点数的运算</h3><p>定点数的移位和加减法是本小节高频考点</p><h5 id="1-定点数的移位">1.定点数的移位</h5><ul><li><p>算数移位</p><blockquote><p>算术移位只针对于<strong>有符号数</strong>，并且在移位的前后，符号位均不会变化</p></blockquote><blockquote><p>正数的原码、补码和反码都是相同的，因此无论左移还是右移，空位补0即可</p></blockquote><blockquote><p>负数的原码移动后补0；负数反码右移和左移都补1；负数补码左移补0，右移补1</p><blockquote><p>对于负数的补码，从右向左找到第一个1，这个1的左边和负数反码一致，而右手边后负数原码一致。这个启示非常方便</p></blockquote></blockquote></li><li><p>逻辑移位</p><p>只需要将操作数看作为无符号数就行了。左移高位丢弃，地位补0；右移低位丢弃，高位补0</p></li><li><p>循环移位</p><p>循环移位，主要有两类，一是带进位标志位的大循环位移，二是不带进位标志位的小循环位移。</p><blockquote><p>区别的依据就是进位标志位是否参与唯一，so easy!</p></blockquote></li></ul><h5 id="2-原码定点数加减法运算">2.原码定点数加减法运算</h5><ul><li><p>加法原则：</p><blockquote><p>判断符号位：</p><p>若相同，则绝对值相加，符号不变</p><p>若不同，则执行减法，绝对值大的减去绝对值小的，符号位同绝对值大者</p></blockquote></li><li><p>减法原则：</p><blockquote><p>将减数的符号取反，将被减数与取反后的减数相加，之后执行加法操作即可</p></blockquote></li></ul><h5 id="3-补码定点数的加减法运算">3.补码定点数的加减法运算</h5><blockquote><p>1.参与运算的操作数都是补码</p><p>2.按照二进制规则运算</p><p>3.符号位和数值位一样要参与运算；符号位产生的进位要丢弃；运算结果的符号由运算得出</p><p>4.运算公式：</p><blockquote><p>[A+B]补=[A]补+[B]补</p><p>[A-B]补=[A]补+[-B]补</p></blockquote></blockquote><h5 id="4-溢出及其判断">4.溢出及其判断</h5><p>溢出顾名思义就是超出了机器所能表示的数字的范围</p><blockquote><p>上溢指的是超过机器所能表示的最大正数</p><p>下溢指的是小于机器所能表示的最小负数</p></blockquote><p>当且仅当两个符号相同的数相加or两个符号相异的数相减才可能发生溢出</p><p>溢出的判断主要有3种方法</p><blockquote><p>1.采用一位符号位</p><p>2.采用双符号位(也叫做模4补码)：</p><blockquote><p>S1S2，其中S1表示本应该是的符号位；S2表示实际运算结果之后的符号位。二者相同才是没有溢出</p></blockquote><p>3.采用一位符号位(也叫做模2补码)，根据数据位的进位情况判断溢出</p><blockquote><p>符号位的进位和最高数据位的进位相同才是没有溢出</p></blockquote></blockquote><hr><h3 id="4-浮点数">4.浮点数</h3><p>1.浮点数表示法在数位有限的情况下，扩大了数的表示范围，保持了数的有效精度</p><p><strong>2.浮点数阶码的底(与尾数的基数相同)是隐含的</strong></p><blockquote><p>浮点数组成：阶符+阶码数值部分+数符+尾数数值部分</p></blockquote><blockquote><p>阶码是整数，阶码符号与阶码的位数共同反应浮点数表示范围和小数点实际位置</p><p>尾码的位数则反应了浮点数的精度</p></blockquote><p><strong>3.规格化浮点数，是为了提高运算的精度。规格化形式规定尾数的最高位数必须是一个有效值。每次规格化之后要注意加码的加减</strong></p><blockquote><p>规格化浮点数M是个小数，不妨设基数为r，则M的取值范围是：</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210824215927.png" alt=""></p></blockquote><p><strong>4.浮点数的尾数可以用原码和补码来表示</strong></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210824220824.png" alt=""></p><p><strong>5.王道知识点小结</strong></p><p>表示范围已经不考了，从408大纲删除了</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210824221821.png" alt=""></p><p><strong>6.IEEE754标准</strong></p><blockquote><p><u>Knowledge Points 1</u></p><p>移码=真值+偏置值</p><p>IEEE754标准出了临时浮点数之外，均采用隐含尾数最高位的方法</p><p>阶码部分全0和全1都用作特殊用途，因此阶码数值部分的表示区间为1&lt;=M&lt;=254</p></blockquote><blockquote><p><u>Knowledge Points 2</u></p><p>阶码部分使用移码表示，而尾数部分用原码表示</p></blockquote><blockquote><p><u>Knowledge Points 3</u></p><p>下图中M表示尾数的数值，而E则表示阶码数值(移码的值)</p><p>对于阶码数值E而言，全0和全1都将作为特殊用途，因此其区间为1&lt;=M&lt;=254</p><p>对于偏置项：规定短浮点数偏置项为127=2^7-1；规定长浮点数偏置项1023=2^10-1</p><blockquote><p>知道了上面的知识，可以很容易求出IEEE754浮点数的表示范围</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825075143.png" alt=""></p></blockquote><p>7.浮点数的加减运算</p><blockquote><p><u>Knowledge Points 1：加减运算</u></p><p>真值到机器数的转换要注意审题</p><p>对阶只能是小阶向大阶看齐，也就是对阶时只能进行右归操作</p><p>舍入，类似于四舍五入</p><p>溢出判断：阶码超位一定是发生了溢出，但是尾数溢出未必导致整体溢出(还可以采用双符号位补救)</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825082327.png" alt=""></p></blockquote><blockquote><p><u>Knowledge Points 2：C强制类型转换</u></p><p>机组考察以32位居多，编写的年代太过于久远</p><p>从int转向float时可能有数据舍入，因为int有32位，而float保留24位。(尾数尾数导致精度)</p><p>从float到int依然可能导致精度损失，一个0.00011的浮点数转换成int就变成了0</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825083215.png" alt=""></p></blockquote><hr><h3 id="5-算数逻辑单元ALU">5.算数逻辑单元ALU</h3><p><strong>1.基本的逻辑运算</strong></p><blockquote><p><code>与</code>运算的优先级是高于<code>或</code>运算的</p><p><code>与</code>运算：两个数都是1，结果才是1</p><p><code>或</code>运算：一个数是1，结果就是1</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825220307.png" alt=""></p></blockquote><p><strong>2.复合逻辑</strong></p><blockquote><p><u>电路符号中的<code>小圆点</code>表示取反</u></p><p><code>与非</code>表示将两个数的结果相与后取非</p><p><code>异或</code>运算本质就是两个参与运算的数，若相同，结果为0；若相异，结果为1</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825221848.png" alt=""></p></blockquote><p><strong>3.串行和并行加法器</strong></p><blockquote><p><u>Knowledge Points 1：一位全加器</u></p></blockquote><blockquote><p><u>Knowledge Points 2：串行全加器</u>：器件少，速度慢，成本低</p></blockquote><blockquote><p><u>Knowledge Points 1：串行进位的并行加法器</u></p></blockquote><blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210825230509.png" alt=""></p></blockquote><p><strong>4.加法器ALU改进</strong></p><p>不是考试重点，大致了解就行了</p><p>心平气和，我能行，我可以！</p><p>人类的本质无非就是套娃再套娃</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸收藏</title>
      <link href="/2021/08/18/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E5%A3%81%E7%BA%B8/"/>
      <url>/2021/08/18/%E6%94%B6%E8%97%8F%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E5%A3%81%E7%BA%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="From-wallroom-io">From <a href="http://wallroom.io">wallroom.io</a></h2><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2560x1440-bg-deb5ad5.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2560x1440-bg-c19542a.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2560x1600-bg-ff0a90b.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-3840x2400-bg-d459300.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2880x1620-bg-ca47e40.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2880x1800-bg-f296f86.jpg" alt=""></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/wallroom-2880x1620-bg-cac0b55.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 乱七八糟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 壁纸收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补码彻底理解</title>
      <link href="/2021/08/18/%E8%A1%A5%E7%A0%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/18/%E8%A1%A5%E7%A0%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="01背景">01背景</h2><p>在算术逻辑单元ALU中，实现减法操作的硬件设计逻辑其实是别加法要复杂的，强行实现的话，会增加很多额外的成本，因此有人提出通过加法操作来实现减法。</p><h2 id="02王道视频">02王道视频</h2><h4 id="1-引子">1.引子</h4><p>将时钟指针从10点调整至7点，可以用两种思路</p><p>一是回调10-7=3个小时；二是从10点转一圈再回到7点，（10+9）mod12=7</p><p>时钟盘面就只有12个小时，因此10+9=19，19再对12做模运算，就等于7</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818123251.png" alt=""></p><h4 id="2-模运算">2.模运算</h4><p>（-3mod12）与（9mod12）其实是等价的</p><p>下图中r的值是在0和模数之间的</p><p>-3=(-1)x12+9；而9=(0)x12+9</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818124019.png" alt=""></p><p>因此在mod12的条件下，-3，9，21…其实是等价的</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818124213.png" alt=""></p><hr><p>因此，根据余数来看，(mod12)操作其实是把所有的整数划分为了(0~11)一共12个类别</p><p>-3操作其实可以变成+9</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818124511.png" alt=""></p><p>在上图中，-3和9的绝对值之和=12，两者互为补数</p><p>所以在(mod m)条件下，如果能够找到负数的补数，就能把减法操作转换为加法操作</p><p>用模-a的绝对值就能求得a的补数，<u>此处的补数是正数</u></p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818125000.png" alt=""></p><h4 id="3-一些疑问">3.一些疑问</h4><p>以88-66为例，88的原码表示为<u>0101</u><u>1000</u>,，而-66的原码表示为<u>1100</u><u>0010</u></p><p>88-66=88+(-66)，因此可以将原式看成88+(-66的补数)</p><p>-66的补码为<u>1011</u><u>1110</u>，此处的10111110不是负数，而是一个正数(可以看成符号位也一起参与运算)</p><p>接着在对<u>0101</u><u>1000</u>和<u>1011</u><u>1110</u>进行加和操作</p><blockquote><p>8位字长最多可以表示0-255共2^8-1个数</p></blockquote><p>因此当两个数的和大于255时，会天然的进行取模操作</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818130543.png" alt=""></p><h4 id="4-总结">4.总结</h4><p>使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器，执行加法操作时候，符号位一起参与运算</p><h2 id="03自己看博客的总结">03自己看博客的总结</h2><p>1.补码实际可以解决0和-0的问题，将+0定位0，将-0设定为最低区间的最大值，从而使得无论是负整数还是负小数都能在最低区间多取得一个最小值。</p><blockquote><p>若字长n+1位，则整数补码区间范围为：</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818135812.png" alt=""></p><blockquote><p>不妨设字长为8，则除去符号位外有7位数值部分，原来表示-0的1000 0000则用来表示-128=-2^8</p></blockquote><hr><p>若字长n+1位，则小数数补码区间范围为：</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818135915.png" alt=""></p><blockquote><p>不妨设字长为8，则除去符号位外有7位数值部分，原来表示-0的1.000 0000则用来表示-1=-2^1</p></blockquote></blockquote><p>2.在模运算的条件下</p><blockquote><p>众所周知，绝对值相等的两个正负数之和为0</p><p>设我们有正数b= 0000 1111，如何表示其相反数呢？</p><p>一般思路是，找一个数，跟它相减的结果等于0</p><p>换一个思路，为什么不找到一个数a，使得a+b=1111 1111</p><p>而a+1就是我们想要的数</p><blockquote><p>此时的(a+b+1)mod8=0</p></blockquote><p>这样就很好的解释了为啥补码等于反码+1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马原_02马哲</title>
      <link href="/2021/08/16/%E9%A9%AC%E5%8E%9F_02%E9%A9%AC%E5%93%B2/"/>
      <url>/2021/08/16/%E9%A9%AC%E5%8E%9F_02%E9%A9%AC%E5%93%B2/</url>
      
        <content type="html"><![CDATA[<h1>0.写在前面</h1><p>马原部分在考研中占有24分左右，其中18分都出自马哲</p><p>这部分分为4章，分别是辩证唯物论、唯物辩证法、认识论和唯物史观</p><p>辩证唯物论：世界是什么？</p><p>唯物辩证法：世界是怎样存在的？</p><p>认识论：如何认知世界？</p><p>唯物史观：人类历史发展规律及特点</p><h1>1.辩证唯物论(世界是什么？)</h1><h3 id="1-1-哲学的基本问题">1.1 哲学的基本问题</h3><p>1.唯物论的两极其实是物质观与意识观。其中物质观是本质，而意识观是派生。</p><p>2.依据物质(存在)与意识(思维)何者为第一性、第二性可分为两派</p><ul><li><p>唯物主义：主张物质第一性，即先有物质后有意识，唯物主义分为3类</p><blockquote><p>古代朴素唯物主义：物质是一种或者几种实物</p></blockquote><blockquote><p>近代形而上学唯物主义：物质是原子等离子(机械思维)</p></blockquote><blockquote><p>现代辩证唯物主义：物质是<strong>一切客观存在</strong></p></blockquote></li><li><p>唯心主义：主张意识第一性，分为2类</p><blockquote><p>主观唯心主义：人的意识是世界本源意识：本我，我思故我在</p></blockquote><blockquote><p>客观唯心主义：独立于”我“之外的客观精神是世界本源意识：上帝创世、道生一，一生二</p></blockquote></li></ul><p>3.依据物质和意识是否具有同一性，即意识是否可以认识物质，可分为<code>可知论</code>与<code>不可知论</code>两个派别</p><blockquote><p>唯物主义和微信主义都坚持可知论，即意识可以认识物质</p></blockquote><blockquote><p>二元论者则坚持不可知论，即意识不能或不能完全认识物质，二元论者也叫做<strong>不彻底</strong>的唯心主义者</p></blockquote><h3 id="1-2-世界的多样性与物质的统一性">1.2 世界的多样性与物质的统一性</h3><p>1.物质是客观存在的，不以人的意志为转移，不依赖人的感觉而存在</p><p>2.物质的唯一特性：客观实在性；物质的根本属性：运动</p><p>3.物质的存在方式是运动；运动的存在方式是时空</p><p>4.物质与运动不可分割</p><blockquote><p>物质是运动着的物质，运动是物质在运动</p><p>你是我的你，我是你的我</p><p>脱离物质谈运动，导致唯心主义；脱离运动谈物质将导致形而上学</p></blockquote><p>5.运动与静止对立统一</p><blockquote><p>对立统一：二者即相联系，又相区别</p><p>相互区别：运动是绝对的，无条件的；静止是相对的，有条件的</p><p>相互联系：动中有静，静中有动</p><p>夸大静止，否定运动，导致形而上学；夸大运动，否定静止，导致诡辩论</p></blockquote><p>6.物质运动与时空是不可分割的</p><blockquote><p>时空具有客观性、绝对性、相对性、有限性和无限性</p><p>绝对性是指：物质运动的时空的客观实在性是绝对存在的</p><p>相对性：相对论</p><p>有限性：具体事物的时空是有限的</p><p>无限性：所有的事物是无限的</p></blockquote><p>7.实践是自然存在和社会存在的区分和统一的基础，即实践是物质和意识的唯一桥梁</p><p>8.意识是人独有的；意识不是物质，物质不是意识；意识在内容上是客观的，在形式上是主观的</p><p>10.语言是物质，但语言的含义是意识</p><p>11.意识对物质具有<strong>能动作用</strong></p><blockquote><p>意识具有目的性、计划性、创新性、指导实践改造客观世界的作用、调控人的行为和生理活动的作用</p></blockquote><p>12.物质与意识是辩证的关系（对立统一）</p><blockquote><p>二者即相联系，有相区别</p></blockquote><h1>2.唯物辩证法(世界是怎样的？)</h1><h3 id="2-1事物的联系和发展">2.1事物的联系和发展</h3><p>1.联系和发展是唯物辩证法的两大特征</p><p>2.联系具有客观性、普遍性和多样性</p><blockquote><p>客观性指客观存在；普遍性有3个，分别是事物内部联系、事物之间联系以及整个世界是统一的；</p></blockquote><p>3.事物的发展的是永恒的，事物的发展是过程的，要以发展的眼光来看待事物</p><blockquote><p>不能凭借先后产生来草率的判断新旧事物</p></blockquote><p>4.五对范畴</p><ul><li><p>原因和结果</p><p>因果关系是前后的关系，但是前后的关系未必是因果</p><p>我是你的因，也是他的果，因果关系的区分既是确定的，也是不确定的</p><p>同样的原因，未必有用样的结果</p><p>有因未必有果(因果关系的复杂多样)</p></li><li><p>必然与偶然</p><p>对立统一关系</p><p>遇到再补充</p></li><li><p>可能与现实</p><p>区分一件事是否可能的依据是，看这件事在现实中是否有依据</p><p>区分一件事是现实的可能还是抽象的可能，是看它在现实中的依据是否充分</p><blockquote><p>抽象的可能有时候也叫做“潜在的可能”</p></blockquote><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818205608.png" alt=""></p></li><li><p>现象与本质</p><p>真象：从正面直接表达事物的本质；假象：从侧面歪曲的表达事物的本质</p><p>无论是真象还是假象都是对事物本质的表达(表现)，区别在于表现的位置点</p><p><u>易错点1</u></p><p>假象不是错觉，错觉是啥都没有；错觉<strong>有可能</strong>是由假象导致的</p><blockquote><p>eg:水里面的筷子弯了，这是假象；我神经病，把一堆筷子看成两堆，这是错觉</p></blockquote><p>真象和假象都是现象，都是客观存在的；不能用<code>正确</code>or<code>错误</code>这类词来形容</p><blockquote><p>eg：我脸圆，无论你说我的脸长得正不正确，你都有毛病</p></blockquote><p>相反，错觉是一种主观的感受，说错觉是一种错误的感觉是正确的</p><p><u>易错点2</u></p><p>真象和假象都是现象，只要是现象一律外露于事物；本质才是隐藏在内部的。</p><p>真相和真象不是一个意思，真相往往指Truth，而真象则是Real</p></li><li><p>内容和形式</p><p>内容决定形式，形式反作用于内容</p><p>生产力=社会生产物质内容</p><p>生产关系=社会生产组织形式</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 考研政治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研政治 </tag>
            
            <tag> 马哲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Server Status服务器探针</title>
      <link href="/2021/08/12/%E5%8F%AF%E4%B9%90%E6%8E%A2%E9%92%88/"/>
      <url>/2021/08/12/%E5%8F%AF%E4%B9%90%E6%8E%A2%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>Server Status是一款适合监控多台服务器的探针程序，自带web前端界面，可以实现监管手上多台服务器，十分方便。</p><p>最近入手了一台水墨云CN2GT线路vps，传家宝价格：99/年，1G 512M内存。</p><p>用来做代理是不合适的，晚高峰炸开，搭网站的话，内存又太小</p><p>用来做探针刚刚合适</p><h3 id="安装脚本">安装脚本</h3><p>1.服务端/客户端安装脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/CokeMine/ServerStatus-Hotaru/master/status.sh &amp;&amp; chmod +x status.sh</span><br><span class="line"></span><br><span class="line">国内服务器专用脚本</span><br><span class="line">wget -N --no-check-certificate http://southcat.net/bash/status.sh &amp;&amp; chmod +x status.sh</span><br></pre></td></tr></table></figure><p>2.服务端/客户端启动脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 客户端管理菜单</span><br><span class="line">bash status.sh c</span><br><span class="line"> </span><br><span class="line"># 服务端管理菜单</span><br><span class="line">bash status.sh s </span><br></pre></td></tr></table></figure><p>3.添加服务器节点什么的也很简答，根据提示一步步走就行了。在服务端安装过程中会要求输入两次端口数值，一次用于客户端和服务端连接，另一次用于使用者访问服务端</p><h3 id="Demo">Demo</h3><p><a href="http://181.215.215.89:3669/">传送门</a></p><p><img src="https://yanxuan.nosdn.127.net/d40ec7f7fd8588354163759def58e476.png" alt="1.png"><br><img src="https://yanxuan.nosdn.127.net/4c83c6a6821bb3ad196e0f3851bbcddc.png" alt="2.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次考研学长分享会记录</title>
      <link href="/2021/08/12/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%80%83%E7%A0%94%E5%AD%A6%E9%95%BF%E5%88%86%E4%BA%AB%E4%BC%9A%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/08/12/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%80%83%E7%A0%94%E5%AD%A6%E9%95%BF%E5%88%86%E4%BA%AB%E4%BC%9A%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-朱佳文学长">1.朱佳文学长</h2><p>择校推荐：灰灰考研，计算机考研助手</p><p>肖4主观全文背诵</p><p><img src="https://yanxuan.nosdn.127.net/91e9de6c241bf88280413fd1b3cc378e.png" alt="1.png"><br><img src="https://yanxuan.nosdn.127.net/1dec2dcdb5c8b4b5bae765d4e4e440fb.png" alt="2.png"></p><p>英语</p><p><img src="https://yanxuan.nosdn.127.net/8a501ff55eb78973ffcd523faf08d276.png" alt="3.png"></p><p>专业课</p><p><img src="https://yanxuan.nosdn.127.net/73983a0509ed89dfb4997a6b13755f1e.png" alt="4.png"></p><p>数学</p><p><img src="https://yanxuan.nosdn.127.net/00fc87a49340aa7ff56643a51f13c39d.png" alt="5.png"></p><p>唠叨几句</p><p><img src="https://yanxuan.nosdn.127.net/713883733587fc97a06fbfe4b6ecc32b.png" alt="6.png"></p><h2 id="2-徐晓敏学长复旦">2.徐晓敏学长复旦</h2><p><img src="https://yanxuan.nosdn.127.net/5c1c4b2fc8fe81923944275e9141e1d3.png" alt="1.png"></p><p><img src="https://yanxuan.nosdn.127.net/53af30f096d88d8098bff7fe053b7d27.png" alt="2.png"></p><p><img src="https://yanxuan.nosdn.127.net/238288b85800e3292e6bb39646b0928a.png" alt="3.png"></p><p><img src="https://yanxuan.nosdn.127.net/95f037e512c7fc092f5c1a3f5d9f1d60.png" alt="4.png"></p><h4 id="初试准备-政治">初试准备-政治</h4><p>政治多选很容易拉开分数，前期不需要准备很长时间，背肖4</p><p><img src="https://yanxuan.nosdn.127.net/abb0c61eef0494351bec3a276364ba78.png" alt="5.png"></p><h4 id="初试准备-英语">初试准备-英语</h4><p>英语作文最好早点准备，考前准备自己的作文模板，各种类型的描述，自己准备好</p><p>考试合理分配好时间，别放弃</p><p><img src="https://yanxuan.nosdn.127.net/6a5baeacb44a59b5e5432f95191541f2.png" alt="6.png"></p><h4 id="初试数学">初试数学</h4><p>群里这种来历不明的题目</p><p>线性代数可以看李永乐 无论真题还是模拟卷都严格控制好时间 真题二刷控制好时间</p><p>唯一方法 好好复习 多多做题 复习要全面 包括“冷门”的知识点</p><p><img src="https://yanxuan.nosdn.127.net/ed2dbf809732e26f0e73ab91429a3d9b.png" alt="7.png"></p><h4 id="初始准备-专业课">初始准备-专业课</h4><p>机组&gt;操作系统&gt;计网&gt;数据结构</p><p>比较难 多多复习 越早越好</p><p>全面，不忽略任何一个知识点，2020年考了十字乘法答题</p><p>视频和教材选王道的就行了，能应付大部分的题目，算法想不起来的话就暴力破解</p><p>数学和专业课成绩会<strong>影响</strong>你找导师</p><p><img src="https://yanxuan.nosdn.127.net/cebf1a5e94089d6110fde7686bf5fcc3.png" alt="8.png"></p><h4 id="哆嗦">哆嗦</h4><p>别空题，把能想到的全部写上去，(抄材料啊啥的)，别空</p><p>要求强大的自控能力</p><p><img src="https://yanxuan.nosdn.127.net/df336c8bb42488dd626d219c35623dd7.png" alt="9.png"></p><h4 id="复试准备">复试准备</h4><p><img src="https://yanxuan.nosdn.127.net/8683dc68a9b0f8b879cd1f1add05b7a9.png" alt="10.png"></p><p>华师大的机试比较难，牛客难度还挺好的，leetcode以后求职面试用的居多，不建议使用Java</p><p>c++学会借助STL标准模板库做题</p><p><img src="https://yanxuan.nosdn.127.net/08164deff65e3ffe6d3e6bd5e750b405.png" alt="11.png"></p><p><img src="https://yanxuan.nosdn.127.net/a36001bd424bc0a34c9b8c57bd674bfe.png" alt="12.png"></p><h4 id="选择导师">选择导师</h4><p><img src="https://yanxuan.nosdn.127.net/083d2a6ac251005f5959d5b6258fe94b.png" alt="13.png"></p><p>导师评价网仅供参考。不一定能够客观</p><p><img src="https://yanxuan.nosdn.127.net/f8af103b3b213d6eb0218f74247da1fd.png" alt="14.png"></p><p>联系导师，实在没东西写，可以谢谢你的毕业设计，不能太水。。</p><p><img src="https://yanxuan.nosdn.127.net/afce4fc9c98a6c0913bd9f34e8919429.png" alt="15.png"></p><p>三天不回复，就直接联系下一位导师</p><p><img src="https://yanxuan.nosdn.127.net/a29533cb4a1abbae8b1c0bd919a6ec44.png" alt="16.png"></p><h4 id="关于读博">关于读博</h4><p><img src="https://yanxuan.nosdn.127.net/b176ab723a00b150b78775bc153290e0.png" alt="17.png"></p><h4 id="考研回忆">考研回忆</h4><p><img src="https://yanxuan.nosdn.127.net/1dbd7d3c7d96468d22ae486c3c42451f.png" alt="18.png"></p><h4 id="最后">最后</h4><p><img src="https://yanxuan.nosdn.127.net/49ce80026c7c09faab809b339fe0ea51.png" alt="19.png"></p><h4 id="学长联系">学长联系</h4><p><img src="https://yanxuan.nosdn.127.net/f933e41870506f1ddb3f73f6d2af6d6b.png" alt="20.png"></p><p>今年学长不推荐考复旦，全年爆冷，今年又会热，可能，如果愿意冲一冲还是可以的。</p><p>考研英语是英译中</p><p>学长是九月底结束的一轮复习的</p><h2 id="3-杜宇航学长">3.杜宇航学长</h2><p>政治学长推荐了《押题笔记》</p><p>上大学硕：数据结构+计算机网络</p><p>专业硕士：数据结+操作系统</p>]]></content>
      
      
      
        <tags>
            
            <tag> learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptable转发脚本</title>
      <link href="/2021/08/12/%E6%90%AC%E8%BF%90iptable%E8%BD%AC%E5%8F%91%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/08/12/%E6%90%AC%E8%BF%90iptable%E8%BD%AC%E5%8F%91%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="0-BBR加速脚本">0.BBR加速脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O tcp.sh mcnb.top/tcp.sh &amp;&amp; bash tcp.sh</span><br></pre></td></tr></table></figure><h2 id="1-原作者Github主页">1.原作者Github主页</h2><p><a href="https://github.com/arloor/iptablesUtils">传送门</a></p><h2 id="2-一键脚本">2.一键脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果vps不能访问 raw.githubusercontent.com 推荐使用这个</span><br><span class="line">wget --no-check-certificate -qO natcfg.sh http://www.arloor.com/sh/iptablesUtils/natcfg.sh &amp;&amp; bash natcfg.sh</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -qO natcfg.sh https://raw.githubusercontent.com/arloor/iptablesUtils/master/natcfg.sh &amp;&amp; bash natcfg.sh</span><br></pre></td></tr></table></figure><h2 id="3-脚本源码">3.脚本源码</h2><p>创建一个txt文档，复制下面的代码进去后，重保存为<strong><a href="http://natcfg.sh">natcfg.sh</a></strong>文件，上传至中转服务器端即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line">red=&quot;\033[31m&quot;</span><br><span class="line">black=&quot;\033[0m&quot;</span><br><span class="line"></span><br><span class="line">base=/etc/dnat</span><br><span class="line">mkdir $base 2&gt;/dev/null</span><br><span class="line">conf=$base/conf</span><br><span class="line">touch $conf</span><br><span class="line"></span><br><span class="line"># wget wget --no-check-certificate -qO natcfg.sh http://blog.arloor.com/sh/iptablesUtils/natcfg.sh &amp;&amp; bash natcfg.sh</span><br><span class="line"></span><br><span class="line">    clear</span><br><span class="line">    echo &quot;#############################################################&quot;</span><br><span class="line">    echo &quot;# Usage: setup iptables nat rules for domian/ip             #&quot;</span><br><span class="line">    echo &quot;# Website:  http://www.arloor.com/                          #&quot;</span><br><span class="line">    echo &quot;# Author: ARLOOR &lt;admin@arloor.com&gt;                         #&quot;</span><br><span class="line">    echo &quot;# Github: https://github.com/arloor/iptablesUtils           #&quot;</span><br><span class="line">    echo &quot;#############################################################&quot;</span><br><span class="line">    echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setupService()&#123;</span><br><span class="line">    cat &gt; /usr/local/bin/dnat.sh &lt;&lt;&quot;AAAA&quot;</span><br><span class="line">#! /bin/bash</span><br><span class="line">[[ &quot;$EUID&quot; -ne &#x27;0&#x27; ]] &amp;&amp; echo &quot;Error:This script must be run as root!&quot; &amp;&amp; exit 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base=/etc/dnat</span><br><span class="line">mkdir $base 2&gt;/dev/null</span><br><span class="line">conf=$base/conf</span><br><span class="line">firstAfterBoot=1</span><br><span class="line">lastConfig=&quot;/iptables_nat.sh&quot;</span><br><span class="line">lastConfigTmp=&quot;/iptables_nat.sh_tmp&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####</span><br><span class="line">echo &quot;正在安装依赖....&quot;</span><br><span class="line">yum install -y bind-utils &amp;&gt; /dev/null</span><br><span class="line">apt install -y dnsutils &amp;&gt; /dev/null</span><br><span class="line">echo &quot;Completed：依赖安装完毕&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">####</span><br><span class="line">turnOnNat()&#123;</span><br><span class="line">    # 开启端口转发</span><br><span class="line">    echo &quot;1. 端口转发开启  【成功】&quot;</span><br><span class="line">    sed -n &#x27;/^net.ipv4.ip_forward=1/&#x27;p /etc/sysctl.conf | grep -q &quot;net.ipv4.ip_forward=1&quot;</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        echo -e &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    #开放FORWARD链</span><br><span class="line">    echo &quot;2. 开放iptbales中的FORWARD链  【成功】&quot;</span><br><span class="line">    arr1=(`iptables -L FORWARD -n  --line-number |grep &quot;REJECT&quot;|grep &quot;0.0.0.0/0&quot;|sort -r|awk &#x27;&#123;print $1,$2,$5&#125;&#x27;|tr &quot; &quot; &quot;:&quot;|tr &quot;\n&quot; &quot; &quot;`)  #16:REJECT:0.0.0.0/0 15:REJECT:0.0.0.0/0</span><br><span class="line">    for cell in $&#123;arr1[@]&#125;</span><br><span class="line">    do</span><br><span class="line">        arr2=(`echo $cell|tr &quot;:&quot; &quot; &quot;`)  #arr2=16 REJECT 0.0.0.0/0</span><br><span class="line">        index=$&#123;arr2[0]&#125;</span><br><span class="line">        echo 删除禁止FOWARD的规则$index</span><br><span class="line">        iptables -D FORWARD $index</span><br><span class="line">    done</span><br><span class="line">    iptables --policy FORWARD ACCEPT</span><br><span class="line">&#125;</span><br><span class="line">turnOnNat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">testVars()&#123;</span><br><span class="line">    local localport=$1</span><br><span class="line">    local remotehost=$2</span><br><span class="line">    local remoteport=$3</span><br><span class="line">    # 判断端口是否为数字</span><br><span class="line">    local valid=</span><br><span class="line">    echo &quot;$localport&quot;|[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ] &amp;&amp; echo $remoteport |[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ]||&#123;</span><br><span class="line">       echo  -e &quot;$&#123;red&#125;本地端口和目标端口请输入数字！！$&#123;black&#125;&quot;;</span><br><span class="line">       return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 检查输入的不是IP</span><br><span class="line">    #if [ &quot;$(echo  $remotehost |grep -E -o &#x27;([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;)&quot; != &quot;&quot; ];then</span><br><span class="line">     #   local isip=true</span><br><span class="line">     #   local remote=$remotehost</span><br><span class="line">#</span><br><span class="line"> #       echo -e &quot;$&#123;red&#125;警告：你输入的目标地址是一个ip!$&#123;black&#125;&quot;</span><br><span class="line">  #      return 2;</span><br><span class="line">   # fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dnat()&#123;</span><br><span class="line">     [ &quot;$#&quot; = &quot;3&quot; ]&amp;&amp;&#123;</span><br><span class="line">        local localport=$1</span><br><span class="line">        local remote=$2</span><br><span class="line">        local remoteport=$3</span><br><span class="line"></span><br><span class="line">        cat &gt;&gt; $lastConfigTmp &lt;&lt;EOF</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport $localport -j DNAT --to-destination $remote:$remoteport</span><br><span class="line">iptables -t nat -A PREROUTING -p udp --dport $localport -j DNAT --to-destination $remote:$remoteport</span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -d $remote --dport $remoteport -j SNAT --to-source $localIP</span><br><span class="line">iptables -t nat -A POSTROUTING -p udp -d $remote --dport $remoteport -j SNAT --to-source $localIP</span><br><span class="line">EOF</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dnatIfNeed()&#123;</span><br><span class="line">  [ &quot;$#&quot; = &quot;3&quot; ]&amp;&amp;&#123;</span><br><span class="line">    local needNat=0</span><br><span class="line">    # 如果已经是ip</span><br><span class="line">    if [ &quot;$(echo  $2 |grep -E -o &#x27;([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;)&quot; != &quot;&quot; ];then</span><br><span class="line">        local remote=$2</span><br><span class="line">    else</span><br><span class="line">        local remote=$(host -t a  $2|grep -E -o &quot;([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;&quot;|head -1)</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$remote&quot; = &quot;&quot; ];then</span><br><span class="line">            echo Warn:解析失败</span><br><span class="line">          return 1;</span><br><span class="line">     fi</span><br><span class="line">  &#125;||&#123;</span><br><span class="line">      echo &quot;Error: host命令缺失或传递的参数数量有误&quot;</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br><span class="line">    echo $remote &gt;$base/$&#123;1&#125;IP</span><br><span class="line">    dnat $1 $remote $3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;3. 开始监听域名解析变化&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">while true ;</span><br><span class="line">do</span><br><span class="line">## 获取本机地址</span><br><span class="line">localIP=$(ip -o -4 addr list | grep -Ev &#x27;\s(docker|lo)&#x27; | awk &#x27;&#123;print $4&#125;&#x27; | cut -d/ -f1 | grep -Ev &#x27;(^127\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^10\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.1[6-9]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.2[0-9]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.3[0-1]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^192\.168\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)&#x27;)</span><br><span class="line">if [ &quot;$&#123;localIP&#125;&quot; = &quot;&quot; ]; then</span><br><span class="line">        localIP=$(ip -o -4 addr list | grep -Ev &#x27;\s(docker|lo)&#x27; | awk &#x27;&#123;print $4&#125;&#x27; | cut -d/ -f1|head -n 1 )</span><br><span class="line">fi</span><br><span class="line">echo  &quot;本机网卡IP [$localIP]&quot;</span><br><span class="line">cat &gt; $lastConfigTmp &lt;&lt;EOF</span><br><span class="line">iptables -t nat -F PREROUTING</span><br><span class="line">iptables -t nat -F POSTROUTING</span><br><span class="line">EOF</span><br><span class="line">arr1=(`cat $conf`)</span><br><span class="line">for cell in $&#123;arr1[@]&#125;</span><br><span class="line">do</span><br><span class="line">    arr2=(`echo $cell|tr &quot;:&quot; &quot; &quot;|tr &quot;&gt;&quot; &quot; &quot;`)  #arr2=16 REJECT 0.0.0.0/0</span><br><span class="line">    # 过滤非法的行</span><br><span class="line">    [ &quot;$&#123;arr2[2]&#125;&quot; != &quot;&quot; -a &quot;$&#123;arr2[3]&#125;&quot; = &quot;&quot; ]&amp;&amp; testVars $&#123;arr2[0]&#125;  $&#123;arr2[1]&#125; $&#123;arr2[2]&#125;&amp;&amp;&#123;</span><br><span class="line">        echo &quot;转发规则： $&#123;arr2[0]&#125; =&gt; $&#123;arr2[1]&#125;:$&#123;arr2[2]&#125;&quot;</span><br><span class="line">        dnatIfNeed $&#123;arr2[0]&#125; $&#123;arr2[1]&#125; $&#123;arr2[2]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">lastConfigTmpStr=`cat $lastConfigTmp`</span><br><span class="line">lastConfigStr=`cat $lastConfig`</span><br><span class="line">if [ &quot;$firstAfterBoot&quot; = &quot;1&quot; -o &quot;$lastConfigTmpStr&quot; != &quot;$lastConfigStr&quot; ];then</span><br><span class="line">    echo &#x27;更新iptables规则[DOING]&#x27;</span><br><span class="line">    source $lastConfigTmp</span><br><span class="line">    cat $lastConfigTmp &gt; $lastConfig</span><br><span class="line">    echo &#x27;更新iptables规则[DONE]，新规则如下：&#x27;</span><br><span class="line">    echo &quot;###########################################################&quot;</span><br><span class="line">    iptables -L PREROUTING -n -t nat --line-number</span><br><span class="line">    iptables -L POSTROUTING -n -t nat --line-number</span><br><span class="line">    echo &quot;###########################################################&quot;</span><br><span class="line">else</span><br><span class="line"> echo &quot;iptables规则未变更&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">firstAfterBoot=0</span><br><span class="line">echo &#x27;&#x27; &gt; $lastConfigTmp</span><br><span class="line">sleep 60</span><br><span class="line">echo &#x27;&#x27;</span><br><span class="line">echo &#x27;&#x27;</span><br><span class="line">echo &#x27;&#x27;</span><br><span class="line">done    </span><br><span class="line">AAAA</span><br><span class="line">echo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &gt; /lib/systemd/system/dnat.service &lt;&lt;\EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=动态设置iptables转发规则</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/root/</span><br><span class="line">EnvironmentFile=</span><br><span class="line">ExecStart=/bin/bash /usr/local/bin/dnat.sh</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=30</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable dnat &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">service dnat stop &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">service dnat start &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 获取本机地址</span><br><span class="line">localIP=$(ip -o -4 addr list | grep -Ev &#x27;\s(docker|lo)&#x27; | awk &#x27;&#123;print $4&#125;&#x27; | cut -d/ -f1 | grep -Ev &#x27;(^127\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^10\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.1[6-9]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.2[0-9]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^172\.3[0-1]&#123;1&#125;[0-9]&#123;0,1&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)|(^192\.168\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$)&#x27;)</span><br><span class="line">if [ &quot;$&#123;localIP&#125;&quot; = &quot;&quot; ]; then</span><br><span class="line">        localIP=$(ip -o -4 addr list | grep -Ev &#x27;\s(docker|lo)&#x27; | awk &#x27;&#123;print $4&#125;&#x27; | cut -d/ -f1|head -n 1 )</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addDnat()&#123;</span><br><span class="line">    local localport=</span><br><span class="line">    local remoteport=</span><br><span class="line">    local remotehost=</span><br><span class="line">    local valid=</span><br><span class="line">    echo -n &quot;本地端口号:&quot; ;read localport</span><br><span class="line">    echo -n &quot;远程端口号:&quot; ;read remoteport</span><br><span class="line">    # echo $localport $remoteport</span><br><span class="line">    # 判断端口是否为数字</span><br><span class="line">    echo &quot;$localport&quot;|[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ] &amp;&amp; echo $remoteport |[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ]||&#123;</span><br><span class="line">        echo  -e &quot;$&#123;red&#125;本地端口和目标端口请输入数字！！$&#123;black&#125;&quot;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo -n &quot;目标域名/IP:&quot; ;read remotehost</span><br><span class="line">    # # 检查输入的不是IP</span><br><span class="line">    # if [ &quot;$remotehost&quot; = &quot;&quot; -o &quot;$(echo  $remotehost |grep -E -o &#x27;([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;)&quot; != &quot;&quot; ];then</span><br><span class="line">    #     isip=true</span><br><span class="line">    #     remote=$remotehost</span><br><span class="line">    #     echo -e &quot;$&#123;red&#125;请输入一个ddns域名$&#123;black&#125;&quot;</span><br><span class="line">    #     return 1</span><br><span class="line">    # fi</span><br><span class="line"></span><br><span class="line">    sed -i &quot;s/^$localport.*/$localport&gt;$remotehost:$remoteport/g&quot; $conf</span><br><span class="line">    [ &quot;$(cat $conf|grep &quot;$localport&gt;$remotehost:$remoteport&quot;)&quot; = &quot;&quot; ]&amp;&amp;&#123;</span><br><span class="line">            cat &gt;&gt; $conf &lt;&lt;LINE</span><br><span class="line">$localport&gt;$remotehost:$remoteport</span><br><span class="line">LINE</span><br><span class="line">    &#125;</span><br><span class="line">    echo &quot;成功添加转发规则 $localport&gt;$remotehost:$remoteport&quot;</span><br><span class="line">    setupService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rmDnat()&#123;</span><br><span class="line">    local localport=</span><br><span class="line">    echo -n &quot;本地端口号:&quot; ;read localport</span><br><span class="line">    sed -i &quot;/^$localport&gt;.*/d&quot; $conf</span><br><span class="line">    echo &quot;done!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testVars()&#123;</span><br><span class="line">    local localport=$1</span><br><span class="line">    local remotehost=$2</span><br><span class="line">    local remoteport=$3</span><br><span class="line">    # 判断端口是否为数字</span><br><span class="line">    local valid=</span><br><span class="line">    echo &quot;$localport&quot;|[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ] &amp;&amp; echo $remoteport |[ -n &quot;`sed -n &#x27;/^[0-9][0-9]*$/p&#x27;`&quot; ]||&#123;</span><br><span class="line">       # echo  -e &quot;$&#123;red&#125;本地端口和目标端口请输入数字！！$&#123;black&#125;&quot;;</span><br><span class="line">       return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # # 检查输入的不是IP</span><br><span class="line">    # if [ &quot;$(echo  $remotehost |grep -E -o &#x27;([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;)&quot; != &quot;&quot; ];then</span><br><span class="line">    #     local isip=true</span><br><span class="line">    #     local remote=$remotehost</span><br><span class="line"></span><br><span class="line">    #     # echo -e &quot;$&#123;red&#125;警告：你输入的目标地址是一个ip!$&#123;black&#125;&quot;</span><br><span class="line">    #     return 2;</span><br><span class="line">    # fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lsDnat()&#123;</span><br><span class="line">    arr1=(`cat $conf`)</span><br><span class="line">for cell in $&#123;arr1[@]&#125;  </span><br><span class="line">do</span><br><span class="line">    arr2=(`echo $cell|tr &quot;:&quot; &quot; &quot;|tr &quot;&gt;&quot; &quot; &quot;`)  #arr2=16 REJECT 0.0.0.0/0</span><br><span class="line">    # 过滤非法的行</span><br><span class="line">    [ &quot;$&#123;arr2[2]&#125;&quot; != &quot;&quot; -a &quot;$&#123;arr2[3]&#125;&quot; = &quot;&quot; ]&amp;&amp; testVars $&#123;arr2[0]&#125;  $&#123;arr2[1]&#125; $&#123;arr2[2]&#125;&amp;&amp;&#123;</span><br><span class="line">        echo &quot;转发规则： $&#123;arr2[0]&#125;&gt;$&#123;arr2[1]&#125;:$&#123;arr2[2]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo  -e &quot;$&#123;red&#125;你要做什么呢（请输入数字）？Ctrl+C 退出本脚本$&#123;black&#125;&quot;</span><br><span class="line">select todo in 增加转发规则 删除转发规则 列出所有转发规则 查看当前iptables配置</span><br><span class="line">do</span><br><span class="line">    case $todo in</span><br><span class="line">    增加转发规则)</span><br><span class="line">        addDnat</span><br><span class="line">        #break</span><br><span class="line">        ;;</span><br><span class="line">    删除转发规则)</span><br><span class="line">        rmDnat</span><br><span class="line">        #break</span><br><span class="line">        ;;</span><br><span class="line">    # 增加到IP的转发)</span><br><span class="line">    #     addSnat</span><br><span class="line">    #     #break</span><br><span class="line">    #     ;;</span><br><span class="line">    # 删除到IP的转发)</span><br><span class="line">    #     rmSnat</span><br><span class="line">    #     #break</span><br><span class="line">    #     ;;</span><br><span class="line">    列出所有转发规则)</span><br><span class="line">        lsDnat</span><br><span class="line">        ;;</span><br><span class="line">    查看当前iptables配置)</span><br><span class="line">        echo &quot;###########################################################&quot;</span><br><span class="line">        iptables -L PREROUTING -n -t nat --line-number</span><br><span class="line">        iptables -L POSTROUTING -n -t nat --line-number</span><br><span class="line">        echo &quot;###########################################################&quot;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;如果要退出，请按Ctrl+C&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nat vps 中转脚本</title>
      <link href="/2021/08/12/Nat%20vps%20%E4%B8%AD%E8%BD%AC%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/08/12/Nat%20vps%20%E4%B8%AD%E8%BD%AC%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基于-socat-转发教程-TCP-UDP">1. 基于 socat 转发教程(TCP+UDP)</h3><blockquote><p>socat是一个多功能的网络工具，名字来由是”Socket CAT”，可以看作是 netcat 的N倍加强版</p></blockquote><h5 id="本脚本支持-CNAME-，支持-TCP-UDP，-不支持端口段转发">本脚本支持 CNAME ，支持 TCP + UDP， 不支持端口段转发</h5><p>脚本默认开启UDP、TCP转发，带开机自启功能，且一次只能转发单个端口，如果想转发多个端口请重复运行本脚本。</p><p><strong>下载脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.moerats.com/usr/shell/socat.sh &amp;&amp; bash socat.sh</span><br></pre></td></tr></table></figure><p><strong>按要求输入以下信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#如果你要用本地服务器的3333端口转发IP为1.1.1.1服务器的6666端口，那就依次填入指定参数。</span><br><span class="line">请输入本地端口:3333</span><br><span class="line">请输入远程端口:6666</span><br><span class="line">请输入远程IP:1.1.1.1</span><br></pre></td></tr></table></figure><h3 id="2-基于-iptables-转发教程-TCP-UDP">2.基于 iptables 转发教程(TCP+UDP)</h3><blockquote><p>iptables 利用 linux 的一个内核模块进行ip包的转发，工作在 linux 的内核态，不涉及内核态和用户态的状态转换</p></blockquote><h5 id="本脚本支持-CNAME-，支持-TCP-UDP，-不支持端口段转发-2">本脚本支持 CNAME ，支持 TCP + UDP， 不支持端口段转发</h5><p><strong>下载 iptables 转发脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO natcfg.sh http://arloor.com/sh/iptablesUtils/natcfg.sh &amp;&amp; bash natcfg.sh</span><br></pre></td></tr></table></figure><p><strong>输出如下：</strong></p><p>用途: 便捷的设置 iptables 端口转发<br>注意1: 到域名的转发规则在添加后需要等待2分钟才会生效，且在机器重启后仍然有效<br>注意2: 到IP的转发规则在重启后会失效，这是iptables的特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你要做什么呢（请输入数字）？Ctrl+C 退出本脚本</span><br><span class="line">1) 增加到域名的转发      3) 增加到IP的转发        5) 列出所有到域名的转发</span><br><span class="line">2) 删除到域名的转发      4) 删除到IP的转发        6) 查看iptables转发规则</span><br><span class="line">#? </span><br><span class="line">此时按照需要，输入1-6中的任意数字，然后按照提示即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> see the world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>408_数据结构_排序章节总结</title>
      <link href="/2021/08/12/408_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2021/08/12/408_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在前面">1.写在前面</h2><p>这一章的知识还是很扎实的，易遗忘度也很高。</p><p>各个算法的时间复杂度、空间复杂度以及稳定性对我来说都是不简单的点，即使是二战再来看某些知识点都还是觉得难。</p><p>外部排序去年的大纲才加入，虽然考察力度不高，但是难度还是在那儿的，今天学习的时候总感觉没掌握好火候，学习起来还是有一定难度。</p><p>这里对内部与外部排序一并做个总结，便于后面复习来看。</p><p>堆排序、快速排序和归并排序是本章的重点</p><h2 id="2-内部排序">2.内部排序</h2><h3 id="a-插入排序">a.插入排序</h3><ul><li><h4 id="直接插入排序">直接插入排序</h4><p><strong>定义</strong>：顾名思义，就是一个表分为有序部分和无序部分，从无序部分选择一个元素同有序部分的元素比较后，插入到有序部分，完成<code>n-1</code>次这样的操作之后就完成排序。</p><p><strong>空间复杂度</strong>：插入排序在实现上通常采用就地排序，使用常数个辅助空间，因此空间复杂度是<code>O(1)</code></p><p><strong>时间复杂度</strong>：无序部分的元素在和有序部分元素比较后，通常还涉及到移动元素，因此时间复杂度是<code>O(n^2)</code></p><blockquote><p>如果原序列有序，则每次插入只用比较而不用移动元素，最好的时间复杂度是O(n)</p></blockquote><p><strong>稳定性</strong>：稳定的</p><blockquote><p>每次排序，都从后面部分拿出元素同前面比较，可以保证稳定</p></blockquote></li><li><h4 id="折半插入排序">折半插入排序</h4><p><strong>定义</strong>：折半插入排序本质上是直接插入排序的优化版，直接插入算法在进行过程中是边比较边移动元素，而折半插入是通过<code>折半查找</code>找到插入位置后，再统一移动后面的元素。</p><p><strong>时间复杂度</strong>：只是减少了查找过程中的时复，移动元素的复杂度依旧没变，折半插入排序的复杂度是<code>O(n^2)</code></p><p><strong>稳定性</strong>：稳定的</p><blockquote><p>得益于折半查找的性质，这个排序算法是稳定的</p><p>在<code>mid</code>所指的元素和无序部分提出的元素相等时，依然执行low=mid+1操作，保证算法稳定性</p></blockquote></li><li><h4 id="希尔排序">希尔排序</h4><p><strong>定义</strong>：引入了增量d，即将一个整表分成了几个子表，依次对子表排序。减少d的值，重复前面的操作。</p><blockquote><p>希尔本人的建议是d每次减少一半</p></blockquote><p><strong>空间复杂度</strong>：使用了常数个辅助单元，因此空间复杂度是<code>O(1)</code></p><p><strong>时间复杂度</strong>：这个问题数学上还没有解决</p><p><strong>稳定性</strong>：显然是<strong>不</strong>稳定的</p><blockquote><p>当相同关键字的元素的被分到不同的子表时，是可能出现相同关键字相对次序改变的情况的</p></blockquote><p><u><strong>注意：希尔排序只适用于线性表为顺序存储的情况</strong></u></p></li></ul><hr><h3 id="b-交换排序">b.交换排序</h3><ul><li><h4 id="冒泡排序">冒泡排序</h4><p><strong>定义</strong>：从后向前or从前向后，两两比较元素的值，若A[i-1]&gt;A[i]则交换，直到序列比较完，这就是第一趟冒泡，冒泡排序每一趟必定有一个元素出现在最终的位置上。</p><p><strong>时间复杂度</strong>：最坏情况下和平均时间复杂度都是<code>O(n^2)</code></p><p><strong>空间复杂度</strong>：使用了常数个辅助单元，因此空间复杂度是<code>O(1)</code></p><p><strong>稳定性</strong>：稳定的</p><blockquote><p>冒泡排序可以用于链表</p></blockquote></li><li><h4 id="快速排序">快速排序</h4><p><strong>定义</strong>：快速排序本质是一种分治的思想。对于初始序列L，从中任意选择一个元素pivot作为枢纽，令a=pivot，设定两个指针low和high分别指向序列L的两头。初始时，high指针从右向左移动，遇到小于a的值，就将此刻L[high]的值赋给L[pivot]；接着移动low指针，遇到大于a的值，就将此刻L[low]的值赋给L[high]。重复上述动作，直达high=low的时候，将a的值赋给L[low]。这样就完成了第一堂排序，此刻L[low]左侧的值都比L[low]小，右侧的都比它大。接着对L[low]两侧进行递归排序即可。</p><p><strong>时间复杂度</strong>：最好和平均时间复杂度都是：</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818224542.png" alt=""></p><p><strong>空间复杂度</strong>：快速排序need一个递归工作站，栈的容量和递归调用时候的最大深度有关最好和平均情况下的空复都是：</p><p><img src="https://fb-1259515475.cos.ap-hongkong.myqcloud.com/blog/20210818225017.png" alt=""></p><p>最坏的情况则是<code>O(n^2)</code></p><p><strong>稳定性</strong>：不稳定</p><blockquote><p>快速排序是所有内部排序算法中平均性能最优的</p><p>快排中，每一趟之后都会有基准元素被放到最终的位置上</p><p>可以通过选择尽量将数据中分的枢纽元素or随机从当前列表选择枢纽元素可以避免最坏的情况发生</p></blockquote></li></ul><hr><h3 id="C-选择排序">C.选择排序</h3><ul><li><h4 id="简单选择排序">简单选择排序</h4><p><strong>定义</strong>：简单选择排序的思想很简单，从待排序列A中选择一个最小的元素和A[i]交换，i从0开始。</p><p><strong>时间复杂度</strong>：简单选择排序的移动次数很少，但比较次数很多，且比较次数与序列初始状态无关，因此时间复杂度是：<code>O(n^2)</code></p><p><strong>空间复杂度</strong>：使用了常数个辅助单元，因此空间复杂度是<code>O(1)</code></p><p><strong>稳定性</strong>：不稳定</p><blockquote><p>这种很容易分析，对于序列[2,<u>2</u>,1]而言，使用简单选择排序会打破稳定性</p></blockquote></li><li><h4 id="堆排序">堆排序</h4></li></ul><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 iperf3 工具测试本地到 VPS 的连接速度</title>
      <link href="/2021/08/12/%E4%BD%BF%E7%94%A8%20iperf3%20%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E9%80%9F%E5%BA%A6/"/>
      <url>/2021/08/12/%E4%BD%BF%E7%94%A8%20iperf3%20%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用 <a href="http://software.es.net/iperf/">iperf3</a> 这个工具可以从本地测试 VPS 可达的最大带宽速度，支持 TCP /UDP 多线程并发测速</p></blockquote><h3 id="安装Iperf3">安装Iperf3</h3><p>Cent OS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iperf3</span><br></pre></td></tr></table></figure><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install iperf3</span><br></pre></td></tr></table></figure><p>macOS 或 Windows 系统，可以从<a href="https://iperf.fr/iperf-download.php">这里下载</a>。</p><h3 id="测速方法">测速方法</h3><p>先在 VPS 上运行 iperf3 进程。其中 <code>-s</code> 参数表示服务器端，<code>-p</code> 指定使用端口（默认端口 5201。别忘了放行端口）。如果需要以守护进程后台运行，追加 <code>-D</code> 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s -p 5201</span><br></pre></td></tr></table></figure><p>然后在本机发起测速。其中 <code>-c</code> 参数表示客户端并指定测速服务器地址，<code>-p</code> 指定服务器端口，<code>-t</code> 指定测试时长（单位秒），<code>-P</code> 指定并发连接数（越高越能测试到速度极限），<code>-R</code> 表示下载测速（不加参数则测试上传速度）。如果要测试 UDP 连接，追加 <code>-u</code> 参数。<a href="http://software.es.net/iperf/invoking.html#iperf3-manual-page">点此查看完整参数</a>。</p><p><strong>Linux向Linux端</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c x.x.x.x -p 5201 -t 30 -P 1 -R</span><br></pre></td></tr></table></figure><p><strong>Windows端向Linux端</strong></p><p>打开<code>cmd</code>窗口，cd到iperf3目录下，执行下面的命令就行了，如果是Nat VPS要提前映射好端口(下面44303端口映射5201端口)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3.exe -c 120.241.154.4 -p 44303 -t 60 -P 10 -R</span><br></pre></td></tr></table></figure><p>运行结果如下图，[SUM] 行就是测试数据（以 receiver 为准），带宽测速平均每秒 194 Mbits。</p><p><img src="https://ddcdn.jd.com/ddimg/jfs/t1/143717/13/6684/36959/5f4611dcE27e74a80/a25e4780d86919cb.png" alt="11.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
